<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>WebChat - Real-time Chat with Video Calls</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- Emoji Picker Element -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@1/index.js"></script>
    <style>
        /* ====== ENHANCED BACKGROUND & UI ====== */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(135deg, #0c1317 0%, #111b21 25%, #1a2730 50%, #111b21 75%, #0c1317 100%),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path fill="%2300a884" fill-opacity="0.03" d="M0,0 L100,0 L100,100 L0,100 Z M20,20 L80,20 L80,80 L20,80 Z M40,40 L60,40 L60,60 L40,60 Z"></path></svg>');
            background-size: auto, 150px;
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 30%, rgba(0, 168, 132, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(37, 211, 102, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 92, 75, 0.1) 0%, transparent 50%),
                repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(0, 168, 132, 0.02) 2px, rgba(0, 168, 132, 0.02) 4px);
            z-index: -1;
            animation: gradientShift 20s ease infinite;
        }

        @keyframes gradientShift {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }

        /* Enhanced message bubbles */
        .message.received {
            background: linear-gradient(135deg, rgba(32, 44, 51, 0.95), rgba(42, 57, 66, 0.95));
            border-left: 3px solid #00a884;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .message.sent {
            background: linear-gradient(135deg, rgba(0, 92, 75, 0.95), rgba(0, 168, 132, 0.95));
            border-right: 3px solid #25D366;
            box-shadow: 0 4px 12px rgba(0, 168, 132, 0.2);
        }

        /* Enhanced buttons */
        .auth-btn,
        .send-button,
        .call-btn.accept {
            background: linear-gradient(135deg, #00a884 0%, #25D366 50%, #128C7E 100%);
            background-size: 200% 200%;
            animation: gradientFlow 3s ease infinite;
            position: relative;
            overflow: hidden;
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .auth-btn::after,
        .send-button::after,
        .call-btn.accept::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.7s;
        }

        .auth-btn:hover::after,
        .send-button:hover::after,
        .call-btn.accept:hover::after {
            left: 100%;
        }

        /* Enhanced chat items */
        .chat-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 12px;
            margin: 2px 8px;
            position: relative;
            overflow: hidden;
        }

        .chat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 168, 132, 0.1), transparent);
            transition: left 0.5s;
        }

        .chat-item:hover::before {
            left: 100%;
        }

        .chat-item:hover {
            background: rgba(42, 57, 66, 0.4);
            transform: translateX(5px);
        }

        .chat-item.active {
            background: linear-gradient(135deg, rgba(0, 92, 75, 0.3), rgba(0, 168, 132, 0.2));
            border-left: 4px solid #00a884;
        }

        /* ====== CAMERA TOGGLE BUTTON ====== */
        .camera-toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(42, 57, 66, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            z-index: 2003;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .video-box:active {
            transform: scale(0.98);
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            align-content: center;
            overflow-y: auto;
        }

        .video-box {
            position: relative;
            background: #1e2a30;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 4/3;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .video-box:hover {
            border-color: #00a884;
            transform: translateY(-2px);
        }

        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 13px;
            backdrop-filter: blur(4px);
            font-weight: 500;
        }

        /* ====== STATUS FEATURE STYLES ====== */
        .status-view {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background: #111b21;
            overflow-y: auto;
        }

        .status-view.active {
            display: flex;
        }

        .status-header {
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            border-bottom: 1px solid #2f3941;
        }

        .status-header h2 {
            font-size: 20px;
            color: #e9edef;
        }

        .status-back-btn {
            color: #aebac1;
            font-size: 20px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .status-back-btn:hover {
            background: #202c33;
        }

        .my-status-section {
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
        }

        .my-status-section:hover {
            background: #202c33;
        }

        .status-avatar-wrapper {
            position: relative;
            width: 50px;
            height: 50px;
        }

        .status-avatar {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: none;
            padding: 0;
            background-clip: border-box;
        }

        .status-avatar.no-status {
            border: none;
            padding: 0;
        }

        .video-status-icon {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
        }

        .add-status-icon {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            background: #00a884;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            border: 2px solid #111b21;
        }

        .status-info h3 {
            font-size: 16px;
            color: #e9edef;
            margin-bottom: 4px;
        }

        .status-info p {
            font-size: 14px;
            color: #8696a0;
        }

        .recent-updates-title {
            padding: 16px 16px 8px;
            font-size: 14px;
            color: #00a884;
            font-weight: 600;
        }

        .status-item {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .status-item:hover {
            background: #202c33;
        }

        .status-ring {
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            border: 1px solid #00a884;
        }

        .status-ring.viewed {
            border-color: #8696a0;
        }

        .my-status-delete-sidebar {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8696a0;
            border-radius: 50%;
            transition: all 0.2s;
            margin-left: auto;
        }

        .my-status-delete-sidebar:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ef4444;
        }

        .view-btn {
            background: #00a884;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .view-btn:hover {
            background: #008f72;
        }

        .status-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 5000;
            display: none;
            flex-direction: column;
            overflow: hidden;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes highlightMessage {
            0% {
                background-color: rgba(0, 168, 132, 0.5);
            }

            100% {
                background-color: transparent;
            }
        }

        .highlight-message {
            animation: highlightMessage 2s ease-out !important;
        }

        .status-modal.active {
            display: flex;
        }

        .status-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            z-index: 5002;
            display: flex;
            gap: 4px;
            padding: 8px 4px 0;
        }

        .status-progress-segment {
            flex: 1;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .status-progress-fill {
            height: 100%;
            background: white;
            width: 0%;
        }

        .status-content-view {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .status-content-view img,
        .status-content-view video {
            max-width: 100%;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .status-viewer-header {
            position: absolute;
            top: 24px;
            left: 0;
            width: 100%;
            padding: 10px 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            color: white;
            z-index: 5001;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), transparent);
        }

        .status-actions {
            position: absolute;
            right: 24px;
            display: flex;
            gap: 20px;
            font-size: 20px;
        }

        .status-footer {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent) !important;
            min-height: 100px;
        }

        .status-action-btn:hover {
            transform: scale(1.2);
            color: #ff0000;
        }

        .status-upload-input {
            display: none;
        }

        .camera-toggle-btn:hover {
            background: rgba(0, 168, 132, 0.8);
            transform: scale(1.1);
        }

        .camera-toggle-btn:active {
            transform: scale(0.95);
        }

        /* ====== LOADER STYLES ====== */
        .loader {
            display: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        .loader.active {
            display: inline-block;
        }

        .auth-btn .loader {
            position: absolute;
            left: 20px;
        }

        .btn-text.loading {
            opacity: 0.7;
        }

        /* ====== ENHANCED GROUP CHAT STYLES ====== */
        .group-avatar {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .group-avatar-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            width: 100%;
            height: 100%;
            gap: 1px;
        }

        .group-avatar-cell {
            background: #25D366;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .group-avatar-cell:nth-child(1) {
            background: #25D366;
        }

        .group-avatar-cell:nth-child(2) {
            background: #128C7E;
        }

        .group-avatar-cell:nth-child(3) {
            background: #075E54;
        }

        .group-avatar-cell:nth-child(4) {
            background: #34B7F1;
        }

        .group-chat-indicator {
            display: inline-block;
            margin-left: 4px;
            color: #8696a0;
            font-size: 12px;
        }

        .group-members {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(42, 57, 66, 0.4);
            border-radius: 10px;
        }

        .group-member {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(0, 168, 132, 0.1);
            border-radius: 12px;
            font-size: 12px;
        }

        .group-member-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #25D366;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
        }

        /* ====== ENHANCED GROUP CHAT MODAL ====== */
        .group-creation-modal .modal-content {
            max-height: 80vh;
            overflow-y: auto;
            background: linear-gradient(135deg, #1a2730, #111b21);
            border: 1px solid rgba(0, 168, 132, 0.3);
            box-shadow: 0 20px 60px rgba(0, 168, 132, 0.2);
        }

        .group-creation-modal h3 {
            background: linear-gradient(135deg, #00a884, #25D366);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: 600;
        }

        .group-members-list {
            max-height: 250px;
            overflow-y: auto;
            background: rgba(32, 44, 51, 0.6);
            border-radius: 16px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .group-member-select {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 12px;
            margin: 6px 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(42, 57, 66, 0.5);
            border: 1px solid transparent;
        }

        .group-member-select:hover {
            background: rgba(0, 168, 132, 0.15);
            transform: translateX(5px);
            border-color: rgba(0, 168, 132, 0.3);
        }

        .group-member-select.selected {
            background: linear-gradient(135deg, rgba(0, 168, 132, 0.25), rgba(37, 211, 102, 0.15));
            border-color: #00a884;
            border-left: 4px solid #00a884;
        }

        .group-member-checkbox {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            border-radius: 6px;
            border: 2px solid #8696a0;
            background: transparent;
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }

        .group-member-select.selected .group-member-checkbox {
            background: #00a884;
            border-color: #00a884;
        }

        .group-member-select.selected .group-member-checkbox::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .group-avatar-preview {
            width: 100px;
            height: 100px;
            margin: 0 auto 25px;
            border-radius: 50%;
            overflow: hidden;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            border: 4px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .group-avatar-preview::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.1));
            border-radius: 50%;
        }

        .group-creation-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 168, 132, 0.1);
            border-radius: 12px;
            font-size: 14px;
            color: #8696a0;
        }

        .group-creation-stats .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .group-creation-stats .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #00a884;
        }

        .group-creation-input {
            background: rgba(42, 57, 66, 0.8) !important;
            border: 2px solid transparent !important;
            border-radius: 16px !important;
            padding: 16px 20px !important;
            color: #e9edef !important;
            font-size: 16px !important;
            transition: all 0.3s !important;
            margin-bottom: 20px !important;
        }

        .group-creation-input:focus {
            outline: none !important;
            border-color: #00a884 !important;
            box-shadow: 0 0 0 4px rgba(0, 168, 132, 0.2) !important;
            background: rgba(42, 57, 66, 0.9) !important;
            transform: translateY(-2px) !important;
        }

        /* ====== MOBILE RESPONSIVE IMAGES ====== */
        .image-preview {
            max-width: min(280px, 85vw) !important;
            max-height: min(280px, 60vh) !important;
            border-radius: 16px;
            cursor: pointer;
            transition: transform 0.3s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            object-fit: cover;
            width: 100%;
            height: auto;
        }

        @media (max-width: 768px) {
            .image-preview {
                max-width: 90vw !important;
                max-height: 50vh !important;
            }

            .image-preview-container {
                width: 100%;
                display: flex;
                justify-content: center;
            }

            .message-content img.image-preview {
                width: auto;
                height: auto;
                max-height: 50vh;
            }
        }

        @media (max-width: 480px) {
            .image-preview {
                max-width: 95vw !important;
                max-height: 40vh !important;
            }
        }

        /* ====== ENHANCED DELETE NOTIFICATION ====== */
        .delete-success-notification {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 168, 132, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 3000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            animation: slideInUp 0.3s ease, fadeOut 2s ease 2s forwards;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }

            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
        }

        /* ====== REST OF THE STYLES ====== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-text-size-adjust: 100%;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
        }

        body {
            background: #0c1317;
            color: #e9edef;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            overscroll-behavior: none;
        }

        .safe-area-top {
            height: env(safe-area-inset-top);
            background: #0c1317;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 9999;
        }

        .safe-area-bottom {
            height: env(safe-area-inset-bottom);
            background: #202c33;
        }

        .performance-optimized {
            will-change: transform, opacity;
            contain: layout style paint;
        }

        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }

        .hardware-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .auth-container {
            width: min(90%, 400px);
            margin: clamp(20px, 8vh, 40px) auto;
            padding: clamp(30px, 5vw, 40px) clamp(25px, 5vw, 30px);
            background: rgba(17, 27, 33, 0.95);
            border-radius: 28px;
            box-shadow: 0 25px 75px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 10;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .auth-form {
            display: none;
            animation: slideIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .auth-form.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .auth-container h2 {
            text-align: center;
            margin-bottom: clamp(25px, 5vw, 30px);
            color: #e9edef;
            font-size: clamp(24px, 5vw, 28px);
            font-weight: 600;
            background: linear-gradient(135deg, #00a884, #25D366);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            position: relative;
            margin-bottom: clamp(15px, 3vw, 20px);
        }

        .auth-container input {
            width: 100%;
            padding: clamp(16px, 4vw, 18px) clamp(16px, 4vw, 18px) clamp(16px, 4vw, 18px) 50px;
            background: rgba(42, 57, 66, 0.8);
            border: 2px solid transparent;
            border-radius: 16px;
            color: #e9edef;
            font-size: clamp(15px, 3.5vw, 16px);
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .auth-container input:focus {
            outline: none;
            border-color: #00a884;
            box-shadow: 0 0 0 4px rgba(0, 168, 132, 0.2);
            background: rgba(42, 57, 66, 0.9);
            transform: translateY(-2px);
        }

        .input-icon {
            position: absolute;
            left: 18px;
            top: 50%;
            transform: translateY(-50%);
            color: #8696a0;
            font-size: clamp(16px, 3.5vw, 18px);
            transition: color 0.3s;
        }

        .auth-container input:focus+.input-icon {
            color: #00a884;
        }

        .auth-btn {
            width: 100%;
            padding: clamp(16px, 4vw, 18px);
            background: linear-gradient(135deg, #00a884, #25D366);
            color: white;
            border: none;
            border-radius: 16px;
            font-size: clamp(16px, 3.8vw, 17px);
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s;
            box-shadow: 0 8px 25px rgba(0, 168, 132, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }

        .auth-btn:active {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 4px 15px rgba(0, 168, 132, 0.4);
        }

        .btn-text {
            position: relative;
            z-index: 1;
        }

        .btn-icon {
            font-size: clamp(16px, 3.8vw, 18px);
            position: relative;
            z-index: 1;
        }

        .auth-switch {
            text-align: center;
            margin-top: clamp(20px, 4vw, 25px);
            color: #8696a0;
            font-size: clamp(14px, 3.3vw, 15px);
            padding: 15px;
            border-radius: 12px;
            background: rgba(42, 57, 66, 0.4);
            backdrop-filter: blur(10px);
        }

        .switch-link {
            color: #53bdeb;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            padding: 4px 8px;
            border-radius: 8px;
            display: inline-block;
        }

        .switch-link:hover {
            background: rgba(83, 189, 235, 0.1);
            transform: translateY(-2px);
        }

        .auth-features {
            display: flex;
            justify-content: space-around;
            margin-top: clamp(25px, 5vw, 30px);
            padding: clamp(15px, 3vw, 20px);
            background: rgba(42, 57, 66, 0.4);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }

        .feature {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            color: #8696a0;
            font-size: clamp(12px, 2.8vw, 13px);
            transition: all 0.3s;
        }

        .feature i {
            font-size: clamp(20px, 4vw, 22px);
            color: #00a884;
            padding: 10px;
            border-radius: 50%;
            background: rgba(0, 168, 132, 0.1);
            transition: all 0.3s;
        }

        .feature:hover {
            color: #e9edef;
            transform: translateY(-5px);
        }

        .feature:hover i {
            background: rgba(0, 168, 132, 0.2);
            transform: scale(1.1);
        }

        .remember-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            gap: 12px;
        }

        .toggle-slider {
            position: relative;
            width: 44px;
            height: 24px;
            background: rgba(42, 57, 66, 0.8);
            border-radius: 24px;
            transition: all 0.3s;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: #8696a0;
            border-radius: 50%;
            transition: all 0.3s;
        }

        input:checked + .toggle-slider {
            background: linear-gradient(135deg, #00a884, #25D366);
            border-color: #00a884;
        }

        input:checked + .toggle-slider::before {
            background: white;
            transform: translateX(20px);
        }

        .toggle-text {
            color: #e9edef;
            font-size: 14px;
            font-weight: 500;
        }

        .floating-animation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .floating-icon {
            position: absolute;
            font-size: clamp(24px, 5vw, 30px);
            color: rgba(0, 168, 132, 0.1);
            animation: float 15s infinite linear;
        }

        .floating-icon:nth-child(1) {
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .floating-icon:nth-child(2) {
            top: 60%;
            right: 15%;
            animation-delay: 5s;
        }

        .floating-icon:nth-child(3) {
            bottom: 20%;
            left: 20%;
            animation-delay: 10s;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
                opacity: 0.1;
            }

            25% {
                transform: translateY(-20px) rotate(90deg);
                opacity: 0.2;
            }

            50% {
                transform: translateY(0) rotate(180deg);
                opacity: 0.1;
            }

            75% {
                transform: translateY(20px) rotate(270deg);
                opacity: 0.2;
            }
        }

        .app-container {
            display: flex;
            height: 100vh;
            max-height: -webkit-fill-available;
            background: #0c1317;
            position: relative;
            overflow: hidden;
        }

        .sidebar {
            width: 100%;
            max-width: 100%;
            height: 100%;
            border-right: 1px solid #2f3941;
            background: #111b21;
            display: flex;
            flex-direction: column;
            position: absolute;
            z-index: 100;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateX(0);
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }

        .user-info {
            background: #202c33;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 60px;
            min-height: 60px;
            flex-shrink: 0;
        }

        .app-title {
            font-size: 18px;
            font-weight: 600;
            color: #e9edef;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: clamp(16px, 4vw, 18px);
        }

        .app-title i {
            color: #00a884;
            font-size: clamp(18px, 4vw, 20px);
        }

        .user-avatar {
            width: clamp(36px, 10vw, 40px);
            height: clamp(36px, 10vw, 40px);
            border-radius: 50%;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: clamp(16px, 4vw, 18px);
            cursor: pointer;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        .user-actions {
            display: flex;
            gap: clamp(12px, 3vw, 20px);
            color: #aebac1;
            position: relative;
        }

        .user-actions i {
            cursor: pointer;
            padding: clamp(6px, 1.5vw, 8px);
            border-radius: 50%;
            transition: background 0.2s;
            font-size: clamp(18px, 4vw, 20px);
        }

        .user-actions i:active {
            background: #2a3942;
            transform: scale(0.95);
        }

        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: #233138;
            border-radius: 12px;
            min-width: min(200px, 70vw);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: none;
            z-index: 1001;
            margin-top: 8px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .menu-dropdown.active {
            display: block;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .menu-item {
            padding: clamp(12px, 3vw, 14px) clamp(14px, 4vw, 16px);
            display: flex;
            align-items: center;
            gap: clamp(10px, 3vw, 12px);
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid #2f3941;
            font-size: clamp(14px, 3.5vw, 16px);
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:active {
            background: #2a3942;
        }

        .menu-item.logout {
            color: #ff6b6b;
        }

        .search-box {
            padding: clamp(10px, 3vw, 12px);
            background: #111b21;
            border-bottom: 1px solid #222e35;
            flex-shrink: 0;
        }

        .search-box input {
            width: 100%;
            padding: clamp(12px, 3vw, 14px) clamp(14px, 4vw, 16px);
            background: #202c33;
            border: none;
            border-radius: 20px;
            color: #e9edef;
            font-size: clamp(14px, 3.5vw, 15px);
            transition: all 0.2s;
        }

        .search-box input:focus {
            outline: none;
            border: 1px solid #005c4b;
            background: #2a3942;
        }

        .chat-list {
            flex: 1;
            overflow-y: auto;
            position: relative;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #374045 transparent;
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }

        .chat-list::-webkit-scrollbar {
            width: 4px;
        }

        .chat-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-list::-webkit-scrollbar-thumb {
            background: #374045;
            border-radius: 2px;
        }

        .chat-item {
            display: flex;
            padding: clamp(12px, 3vw, 14px);
            border-bottom: 1px solid #222e35;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
            align-items: center;
            min-height: 72px;
        }

        .chat-item:active {
            background: #202c33;
        }

        .chat-item.active {
            background: #2a3942;
        }

        .chat-avatar {
            width: clamp(48px, 12vw, 52px);
            height: clamp(48px, 12vw, 52px);
            border-radius: 50%;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: clamp(10px, 3vw, 12px);
            font-weight: bold;
            color: white;
            font-size: clamp(18px, 4vw, 20px);
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        .chat-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            align-items: center;
            gap: 8px;
        }

        .chat-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: clamp(15px, 3.8vw, 17px);
            color: rgb(255, 255, 255);
        }

        .chat-time {
            font-size: clamp(11px, 2.8vw, 12px);
            color: #aebac1;
            flex-shrink: 0;
        }

        .chat-preview {
            display: flex;
            align-items: center;
            gap: 5px;
            min-height: 20px;
        }

        .chat-message {
            font-size: clamp(13px, 3.3vw, 14px);
            color: #8696a0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .unread-badge {
            background: #00a884;
            color: white;
            font-size: clamp(11px, 2.8vw, 12px);
            font-weight: bold;
            padding: 2px clamp(6px, 2vw, 8px);
            border-radius: 12px;
            min-width: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .chat-actions-menu {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            gap: 5px;
        }

        .chat-item:hover .chat-actions-menu {
            display: flex;
        }

        .chat-action-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(42, 57, 66, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aebac1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            margin-left: 8px;
            color: rgb(11, 246, 11);
        }

        .chat-action-btn:hover {
            background: #2a3942;
            transform: scale(1.1);
        }

        .chat-action-btn.delete:hover {
            background: #d32f2f;
            color: white;
        }

        .chat-area {
            flex: 1;
            display: none;
            flex-direction: column;
            background: #0c1317;
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .chat-area.active {
            display: flex;
            transform: translateX(0);
        }

        .chat-header-area {
            background: #202c33;
            padding: clamp(12px, 3vw, 14px) clamp(14px, 4vw, 16px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 60px;
            flex-shrink: 0;
            border-bottom: 1px solid #2f3941;
        }

        .chat-contact {
            display: flex;
            align-items: center;
            gap: clamp(10px, 3vw, 12px);
            flex: 1;
            min-width: 0;
        }

        .chat-contact-name {
            font-weight: 500;
            font-size: clamp(16px, 4vw, 17px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-contact-status {
            font-size: clamp(12px, 3vw, 13px);
            color: #8696a0;
        }

        .chat-actions {
            display: flex;
            gap: clamp(12px, 3vw, 16px);
            color: #aebac1;
            flex-shrink: 0;
        }

        .chat-actions i {
            cursor: pointer;
            padding: clamp(8px, 2vw, 10px);
            border-radius: 50%;
            transition: background 0.2s;
            font-size: clamp(18px, 4vw, 20px);
        }

        .chat-actions i:active {
            background: #2a3942;
            transform: scale(0.95);
        }

        .back-to-chats {
            display: flex;
            cursor: pointer;
            padding: clamp(8px, 2vw, 10px);
            border-radius: 50%;
            transition: background 0.2s;
            margin-right: clamp(8px, 2vw, 10px);
            font-size: clamp(18px, 4vw, 20px);
            flex-shrink: 0;
        }

        .back-to-chats:active {
            background: #2a3942;
            transform: scale(0.95);
        }

        .messages-container {
            flex: 1;
            padding: clamp(12px, 3vw, 16px);
            overflow-y: auto;
            background-color: #0b141a;
            background-image: linear-gradient(rgba(11, 20, 26, 0.95), rgba(11, 20, 26, 0.95)), url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
            background-repeat: repeat;
            background-size: 400px;
            display: flex;
            flex-direction: column;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            position: relative;
        }

        .encryption-notice {
            text-align: center;
            padding: 8px 16px;
            font-size: 12px;
            color: #8696a0;
            background: rgba(42, 57, 66, 0.8);
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .message-row {
            display: flex;
            margin-bottom: 8px;
            animation: fadeIn 0.3s ease-out;
        }

        .message-row.sent {
            justify-content: flex-end;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message {
            max-width: min(80%, 400px);
            padding: clamp(8px, 2vw, 10px) clamp(10px, 2.5vw, 14px);
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            word-break: break-word;
            transition: transform 0.2s;
            font-size: clamp(14px, 3.5vw, 15px);
            line-height: 1.5;
            -webkit-user-select: text;
            user-select: text;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        @media (max-width: 768px) {
            .messages-container {
                padding: clamp(8px, 2vw, 12px);
            }

            .message {
                max-width: 85%;
                padding: 10px 12px;
                font-size: 15px;
            }

            .message-row {
                margin-bottom: 6px;
            }
        }

        .message:active {
            opacity: 0.9;
            transform: scale(0.98);
        }

        .message-content {
            margin-bottom: 5px;
            line-height: 1.4;
            font-size: clamp(14px, 3.5vw, 15px);
        }

        .message-link {
            color: #53bdeb;
            text-decoration: underline;
            word-break: break-all;
        }

        .message-link:hover {
            color: #25d366;
        }

        .youtube-preview {
            margin: 10px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .youtube-preview iframe {
            border-radius: 8px;
            border: none;
        }

        .link-preview {
            margin: 8px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            max-width: 300px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .link-preview:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }

        .link-preview-image {
            width: 100%;
            height: 150px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .link-preview-content {
            padding: 12px;
        }

        .link-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 4px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .link-preview-description {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .link-preview-url {
            font-size: 11px;
            color: #53bdeb;
            margin-top: 4px;
            text-decoration: none;
        }

        .link-preview-url:hover {
            text-decoration: underline;
        }

        .message-time {
            font-size: clamp(10px, 2.5vw, 11px);
            color: rgba(255, 255, 255, 0.6);
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
        }

        .blue-tick {
            color: #53bdeb;
        }

        .message-context-menu {
            position: fixed;
            background: rgba(35, 49, 56, 0.98);
            border-radius: 16px;
            padding: 8px 0;
            min-width: 200px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            z-index: 10000;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.15);
            display: none;
        }

        .message-context-menu.active {
            display: block;
            animation: slideDown 0.2s ease;
        }

        .context-menu-item {
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 15px;
            color: #e9edef;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .context-menu-item:active {
            background: rgba(42, 57, 66, 0.9);
            transform: scale(0.98);
        }

        .context-menu-item i {
            font-size: 18px;
            width: 20px;
            text-align: center;
        }

        .context-menu-item.copy {
            color: #53bdeb;
        }

        .context-menu-item.reply {
            color: #00a884;
        }

        .context-menu-item.forward {
            color: #ff9800;
        }

        .context-menu-item.delete {
            color: #ff6b6b;
        }

        /* Mobile-specific context menu styles */
        @media (max-width: 768px) {
            .message-context-menu {
                min-width: 220px;
                border-radius: 20px;
                padding: 10px 0;
            }

            .context-menu-item {
                padding: 18px 24px;
                font-size: 16px;
                min-height: 56px;
            }

            .context-menu-item i {
                font-size: 20px;
            }
        }


        .message-input-area {
            padding: 8px;
            min-height: 0px;
        }
        .input-main-row {
            display: flex;
            align-items: center;
            gap: clamp(8px, 2vw, 12px);
            margin-bottom: 44px;
        }

        .reply-preview-container {
            display: none;
            background: rgba(42, 57, 66, 0.6);
            border-radius: 12px;
            margin-bottom: 4px;
            border-left: 4px solid #00a884;
            padding: 8px 12px;
            position: relative;
            animation: slideInDown 0.2s ease-out;
        }

        .reply-preview-container.active {
            display: block;
        }

        .reply-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .reply-preview-sender {
            color: #00a884;
            font-size: 13px;
            font-weight: 600;
        }

        .reply-preview-close {
            color: #8696a0;
            cursor: pointer;
            font-size: 14px;
        }

        .reply-preview-text {
            color: #d1d7db;
            font-size: 13px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.4;
        }

        .replied-message-bubble {
            background: rgba(0, 0, 0, 0.15);
            border-left: 4px solid #00a884;
            border-radius: 8px;
            padding: 6px 10px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .replied-message-bubble:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        .replied-sender-name {
            color: #00a884;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .replied-text-content {
            color: #d1d7db;
            font-size: 12px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            background: #2a3942;
            border-radius: 24px;
            padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 16px);
            align-items: center;
            position: relative;
        }

        .input-wrapper input {
            flex: 1;
            background: transparent;
            border: none;
            color: #e9edef;
            font-size: clamp(14px, 3.5vw, 16px);
            outline: none;
            min-width: 0;
        }

        .input-actions {
            display: flex;
            gap: clamp(8px, 2vw, 12px);
            color: #8696a0;
            position: relative;
            flex-shrink: 0;
        }

        .input-actions i,
        .input-wrapper i {
            cursor: pointer;
            padding: clamp(8px, 2vw, 10px);
            border-radius: 50%;
            transition: background 0.2s;
            font-size: clamp(18px, 4vw, 20px);
        }

        .input-actions i:active,
        .input-wrapper i:active {
            background: #2a3942;
            transform: scale(0.95);
        }

        .send-button {
            background: #005c4b;
            color: white;
            border: none;
            border-radius: 50%;
            width: clamp(44px, 11vw, 48px);
            height: clamp(44px, 11vw, 48px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 16px rgba(0, 92, 75, 0.3);
            flex-shrink: 0;
        }

        .send-button:hover {
            background: #0a7c68;
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 92, 75, 0.4);
        }

        .send-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 92, 75, 0.2);
        }

        /* ====== EMOJI PICKER ELEMENT STYLING ====== */
        .emoji-picker-container {
            display: none;
            z-index: 1000;
            position: relative;
        }

        .emoji-picker-container.show {
            display: block !important;
        }

        /* Close button for emoji picker */
        .emoji-picker-close {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #8696a0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .emoji-picker-close:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #e9edef;
            transform: scale(1.1);
        }

        .emoji-picker-close:active {
            transform: scale(0.95);
        }

        /* Desktop - positioned above input */
        @media (min-width: 769px) {
            .emoji-picker-container {
                position: absolute;
                bottom: 100%;
                left: 0;
                right: 0;
                margin-bottom: 8px;
            }

            .emoji-picker-close {
                display: none !important;
            }
        }

        /* Mobile - bottom sheet modal */
        @media (max-width: 768px) {
            .emoji-picker-container {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                max-width: 100%;
                margin: 0;
                animation: slideUpMobile 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                border-radius: 24px 24px 0 0 !important;
                padding: 12px 0 0 0;
            }

            .emoji-picker-close {
                display: flex !important;
            }

            .emoji-picker-container::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.4);
                z-index: -1;
                animation: fadeIn 0.3s ease-out;
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUpMobile {
            from {
                opacity: 0;
                transform: translateY(100%);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 0.4;
            }
        }

        /* Beautiful emoji-picker-element styling */
        emoji-picker {
            --bg-color: #232f38;
            --border-color: rgba(255, 255, 255, 0.1);
            --category-button-bg-color: rgba(42, 57, 66, 0.3);
            --category-button-hover-bg-color: rgba(42, 57, 66, 0.6);
            --category-button-active-bg-color: rgba(0, 168, 132, 0.3);
            --indicator-color: #25d366;
            --outline-color: rgba(0, 168, 132, 0.5);
            --input-border-color: rgba(255, 255, 255, 0.1);
            --input-border-focus-color: rgba(0, 168, 132, 0.5);
            --input-bg-color: rgba(42, 57, 66, 0.8);
            --input-text-color: #e9edef;
            --input-placeholder-color: #8696a0;
            --emoji-size: 1.8rem;
            --emoji-padding: 0.6rem;
            width: 100%;
            max-width: 100vw;
            height: 350px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            animation: slideUp 0.3s ease-out;
        }

        /* Override text colors for dark theme */
        emoji-picker::part(picker) {
            background: var(--bg-color) !important;
            border: none !important;
        }

        emoji-picker::part(emoji) {
            transition: all 0.2s ease !important;
            border-radius: 8px !important;
            cursor: pointer !important;
        }

        emoji-picker::part(emoji):hover {
            background: rgba(42, 57, 66, 0.6) !important;
            transform: scale(1.2) !important;
        }

        emoji-picker::part(emoji):active {
            transform: scale(0.95) !important;
        }

        emoji-picker::part(search) {
            background: var(--input-bg-color) !important;
            border: 1px solid var(--input-border-color) !important;
            border-radius: 12px !important;
            color: var(--input-text-color) !important;
            padding: 10px 14px !important;
            font-size: 16px !important;
        }

        emoji-picker::part(search):focus {
            border-color: var(--input-border-focus-color) !important;
            background: rgba(42, 57, 66, 0.95) !important;
            outline: none !important;
        }

        emoji-picker::part(category-button) {
            color: #8696a0 !important;
            background: transparent !important;
            border: none !important;
            transition: all 0.2s ease !important;
            padding: 10px !important;
            font-size: 20px !important;
            cursor: pointer !important;
        }

        emoji-picker::part(category-button):hover {
            background: var(--category-button-hover-bg-color) !important;
            transform: scale(1.1) !important;
        }

        emoji-picker::part(category-button):active {
            transform: scale(0.95) !important;
        }

        emoji-picker::part(category-button)[selected] {
            background: var(--category-button-active-bg-color) !important;
            color: #25d366 !important;
        }

        /* Scrollbar styling */
        emoji-picker::-webkit-scrollbar {
            width: 6px;
        }

        emoji-picker::-webkit-scrollbar-track {
            background: transparent;
        }

        emoji-picker::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        emoji-picker::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Desktop responsiveness */
        @media (min-width: 1200px) {
            emoji-picker {
                --emoji-size: 2rem;
                --emoji-padding: 0.7rem;
                height: 380px;
            }
        }

        /* Tablet responsiveness */
        @media (min-width: 769px) and (max-width: 1199px) {
            emoji-picker {
                --emoji-size: 1.8rem;
                --emoji-padding: 0.6rem;
                height: 360px;
            }
        }

        /* Mobile - Large phones */
        @media (max-width: 768px) and (min-width: 481px) {
            emoji-picker {
                --emoji-size: 1.6rem;
                --emoji-padding: 0.5rem;
                height: calc(100vh - 200px);
                max-height: 420px;
                border-radius: 24px 24px 0 0 !important;
            }
        }

        /* Mobile - Small phones */
        @media (max-width: 480px) {
            emoji-picker {
                --emoji-size: 1.5rem;
                --emoji-padding: 0.4rem;
                height: calc(100vh - 180px);
                max-height: 350px;
                border-radius: 24px 24px 0 0 !important;
            }
        }

        /* Extra small phones */
        @media (max-height: 600px) {
            emoji-picker {
                height: calc(100vh - 160px) !important;
            }
        }

        /* Mobile responsive adjustments */
        @media (max-width: 480px) {
            .emoji-button-container {
                width: calc(100vw - 16px) !important;
                max-width: calc(100vw - 16px) !important;
                border-radius: 12px !important;
                max-height: 250px !important;
            }

            .emoji-button-container .emoji {
                font-size: 24px !important;
            }

            .emoji-button-container .category-button {
                padding: 6px !important;
                font-size: 18px;
            }
        }

        /* Fallback styles for old emoji picker elements */

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .attachment-menu {
            position: absolute;
            bottom: 100%;
            left: clamp(8px, 2vw, 12px);
            background: rgba(35, 49, 56, 0.95);
            border-radius: 20px;
            padding: clamp(8px, 2vw, 12px);
            display: none;
            flex-direction: column;
            gap: clamp(8px, 2vw, 12px);
            min-width: min(180px, 60vw);
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .attachment-menu.active {
            display: flex;
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .attachment-option {
            display: flex;
            align-items: center;
            gap: clamp(8px, 2vw, 12px);
            padding: clamp(8px, 2vw, 12px);
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.2s;
            font-size: clamp(14px, 3.5vw, 15px);
        }

        .attachment-option:active {
            background: rgba(42, 57, 66, 0.8);
            transform: translateX(4px);
        }

        .online-dot {
            width: clamp(10px, 2.5vw, 12px);
            height: clamp(10px, 2.5vw, 12px);
            background: #00a884;
            border-radius: 50%;
            position: absolute;
            bottom: 2px;
            right: 2px;
            border: 2px solid #111b21;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .avatar-container {
            position: relative;
            display: inline-block;
        }

        .empty-chat {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: clamp(20px, 5vw, 40px);
        }

        .empty-chat-icon {
            font-size: clamp(60px, 15vw, 80px);
            color: #2a3942;
            margin-bottom: clamp(16px, 4vw, 20px);
            opacity: 0.5;
        }

        .empty-chat h3 {
            margin-bottom: clamp(8px, 2vw, 10px);
            color: #e9edef;
            font-size: clamp(18px, 4.5vw, 20px);
        }

        .empty-chat p {
            color: #8696a0;
            max-width: min(280px, 90vw);
            line-height: 1.5;
            font-size: clamp(14px, 3.5vw, 15px);
        }

        .search-result-item {
            display: flex;
            padding: clamp(12px, 3vw, 14px);
            border-bottom: 1px solid #222e35;
            cursor: pointer;
            transition: background 0.2s;
            align-items: center;
        }

        .search-result-item:active {
            background: #202c33;
        }

        .search-result-item .chat-avatar {
            width: clamp(44px, 11vw, 48px);
            height: clamp(44px, 11vw, 48px);
            margin-right: clamp(8px, 2vw, 12px);
            font-size: clamp(16px, 4vw, 18px);
        }

        .search-result-info {
            flex: 1;
            min-width: 0;
        }

        .search-result-name {
            font-weight: 500;
            margin-bottom: 3px;
            font-size: clamp(15px, 3.8vw, 16px);
        }

        .search-result-email {
            font-size: clamp(12px, 3vw, 13px);
            color: #8696a0;
        }

        .no-results {
            text-align: center;
            padding: clamp(30px, 8vw, 40px) clamp(20px, 5vw, 30px);
            color: #8696a0;
            font-style: italic;
            font-size: clamp(14px, 3.5vw, 15px);
        }

        .spinner {
            width: clamp(36px, 9vw, 40px);
            height: clamp(36px, 9vw, 40px);
            border: 4px solid rgba(243, 243, 243, 0.3);
            border-top: 4px solid #005c4b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: clamp(20px, 5vw, 30px) auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .system-message {
            text-align: center;
            margin: clamp(8px, 2vw, 10px) 0;
            font-size: clamp(12px, 3vw, 13px);
            color: #8696a0;
            font-style: italic;
            padding: 0 clamp(8px, 2vw, 12px);
        }

        .file-message {
            display: flex;
            align-items: center;
            gap: clamp(8px, 2vw, 12px);
            padding: clamp(10px, 2.5vw, 12px);
            background: rgba(42, 57, 66, 0.8);
            border-radius: 16px;
            max-width: min(300px, 85vw);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .file-icon {
            font-size: clamp(24px, 6vw, 28px);
            color: #53bdeb;
            flex-shrink: 0;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-size: clamp(14px, 3.5vw, 15px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }

        .file-size {
            font-size: clamp(11px, 2.8vw, 12px);
            color: #8696a0;
        }

        .file-size-warning {
            color: #ff9800;
            font-size: clamp(11px, 2.8vw, 12px);
            margin-top: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .download-btn {
            background: #005c4b;
            color: white;
            border: none;
            border-radius: 50%;
            width: clamp(32px, 8vw, 36px);
            height: clamp(32px, 8vw, 36px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0, 92, 75, 0.3);
        }

        .download-btn:active {
            background: #0a7c68;
            transform: scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 92, 75, 0.4);
        }

        .image-preview-container {
            position: relative;
            display: inline-block;
        }

        .image-preview-container:hover .image-overlay {
            display: flex;
        }

        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
        }

        .image-download-btn {
            background: rgba(0, 92, 75, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 18px;
        }

        .image-download-btn:hover {
            background: #0a7c68;
            transform: scale(1.1);
        }

        .voice-message-container {
            display: flex;
            align-items: center;
            gap: clamp(8px, 2vw, 12px);
            padding: clamp(10px, 2.5vw, 12px);
            background: rgba(42, 57, 66, 0.8);
            border-radius: 24px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .voice-wave {
            display: flex;
            align-items: center;
            gap: 3px;
            height: clamp(20px, 5vw, 24px);
        }

        .voice-bar {
            width: 3px;
            background: #53bdeb;
            border-radius: 1.5px;
            animation: wave 1s ease-in-out infinite;
        }

        @keyframes wave {

            0%,
            100% {
                height: 6px;
            }

            50% {
                height: 18px;
            }
        }

        .voice-duration {
            font-size: clamp(12px, 3vw, 13px);
            color: #8696a0;
        }

        .location-message {
            max-width: min(280px, 85vw);
            border-radius: 16px;
            overflow: hidden;
            background: rgba(42, 57, 66, 0.8);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .location-preview {
            width: 100%;
            height: clamp(140px, 35vw, 160px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .location-icon {
            font-size: clamp(40px, 10vw, 48px);
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .location-info {
            padding: clamp(10px, 2.5vw, 12px);
        }

        .location-address {
            font-size: clamp(13px, 3.3vw, 14px);
            margin-bottom: clamp(6px, 1.5vw, 8px);
            line-height: 1.4;
        }

        .location-coordinates {
            font-size: clamp(11px, 2.8vw, 12px);
            color: #8696a0;
            margin-bottom: clamp(10px, 2.5vw, 12px);
        }

        .location-actions {
            display: flex;
            gap: clamp(6px, 1.5vw, 8px);
        }

        .location-btn {
            flex: 1;
            padding: clamp(8px, 2vw, 10px) clamp(10px, 2.5vw, 12px);
            background: #005c4b;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: clamp(12px, 3vw, 13px);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(4px, 1vw, 6px);
            text-align: center;
        }

        .location-btn:active {
            background: #0a7c68;
            transform: translateY(2px);
        }

        .satellite-view {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .satellite-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #8696a0;
        }

        .satellite-map {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            gap: 2px;
            padding: 10px;
        }

        .grid-row {
            display: contents;
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .grid-cell.road {
            background: rgba(169, 169, 169, 0.3);
        }

        .grid-cell.building {
            background: rgba(139, 0, 0, 0.3);
        }

        .grid-cell.water {
            background: rgba(30, 144, 255, 0.3);
        }

        .grid-cell.park {
            background: rgba(34, 139, 34, 0.3);
        }

        .location-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        .satellite-address {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .location-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .satellite-btn,
        .refresh-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 10px;
            background: rgba(42, 57, 66, 0.8);
            color: #8696a0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .satellite-btn:active,
        .refresh-btn:active {
            background: rgba(42, 57, 66, 1);
            transform: scale(0.95);
        }

        .accuracy-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
            backdrop-filter: blur(10px);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: clamp(16px, 4vw, 20px);
        }

        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: #2a3942;
            padding: clamp(20px, 5vw, 24px);
            border-radius: 24px;
            width: min(90%, 380px);
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }



        .delete-options {
            display: flex;
            flex-direction: column;
            gap: clamp(10px, 2.5vw, 12px);
            margin-top: clamp(16px, 4vw, 20px);
        }

        .delete-option {
            padding: clamp(14px, 3.5vw, 16px);
            border: 1px solid #3d4b54;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .delete-option:active {
            background: #2a3942;
            border-color: #005c4b;
            transform: translateY(-2px);
        }

        .delete-option.selected {
            background: rgba(35, 49, 56, 0.8);
            border-color: #005c4b;
            border-width: 2px;
        }

        .delete-option-title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: clamp(15px, 3.8vw, 16px);
        }

        .delete-option-desc {
            font-size: clamp(12px, 3vw, 13px);
            color: #8696a0;
            line-height: 1.4;
        }

        .modal-buttons {
            display: flex;
            gap: clamp(10px, 2.5vw, 12px);
            margin-top: 20px;
            justify-content: flex-end;
        }

        /* Settings Modal Styles */
        .settings-modal-content {
            background: #111b21;
            width: min(98%, 480px);
            border-radius: 24px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 90vh;
        }

        .settings-header-top {
            padding: 24px;
            background: #202c33;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .settings-header-top h3 {
            margin: 0;
            font-size: 20px;
            color: #e9edef;
        }

        .settings-profile-preview {
            padding: 20px 24px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.02);
            margin-bottom: 15px;
            transition: background 0.2s;
        }

        .settings-profile-preview:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .settings-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
        }

        .settings-body {
            overflow-y: auto;
            padding-bottom: 20px;
        }

        .settings-item {
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .settings-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .settings-icon {
            font-size: 20px;
            color: #8696a0;
            width: 24px;
            text-align: center;
        }

        .settings-text h4 {
            font-size: 16px;
            color: #e9edef;
            margin: 0;
            font-weight: normal;
        }

        .settings-text p {
            font-size: 13px;
            color: #8696a0;
            margin: 4px 0 0;
        }

        .modal-buttons button {
            flex: 1;
            padding: clamp(12px, 3vw, 14px);
            border: none;
            border-radius: 16px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: clamp(14px, 3.5vw, 16px);
        }

        .modal-buttons button:active {
            transform: translateY(2px);
        }

        .modal-delete {
            background: #d32f2f;
            color: white;
            box-shadow: 0 4px 16px rgba(211, 47, 47, 0.3);
        }

        .modal-delete:active {
            background: #b71c1c;
            box-shadow: 0 2px 8px rgba(211, 47, 47, 0.4);
        }

        .modal-cancel {
            background: #8696a0;
            color: white;
        }

        .modal-cancel:active {
            background: #6a7883;
        }

        .call-interface {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0c1317;
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: clamp(16px, 4vw, 20px);
        }

        .call-interface.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .call-contact {
            text-align: center;
            margin-bottom: clamp(30px, 8vw, 40px);
            z-index: 2002;
            padding: 0 clamp(16px, 4vw, 20px);
        }

        .call-avatar {
            width: clamp(120px, 30vw, 140px);
            height: clamp(120px, 30vw, 140px);
            border-radius: 50%;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(48px, 12vw, 56px);
            color: white;
            margin: 0 auto clamp(16px, 4vw, 20px);
            background-size: cover;
            background-position: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 4px solid rgba(255, 255, 255, 0.1);
        }

        .call-status {
            font-size: clamp(18px, 4.5vw, 20px);
            color: #e9edef;
            margin-bottom: clamp(8px, 2vw, 10px);
            font-weight: 500;
        }

        .call-timer {
            font-size: clamp(14px, 3.5vw, 16px);
            color: #8696a0;
        }

        .call-controls {
            display: flex;
            gap: clamp(20px, 5vw, 30px);
            margin-top: clamp(30px, 8vw, 50px);
            z-index: 2002;
        }

        .call-btn {
            width: clamp(60px, 15vw, 70px);
            height: clamp(60px, 15vw, 70px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: clamp(24px, 6vw, 28px);
            transition: all 0.2s;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .call-btn:active {
            transform: scale(0.95);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }

        .call-btn.hangup {
            background: #d32f2f;
            color: white;
        }

        .call-btn.hangup:active {
            background: #b71c1c;
        }

        .call-btn.mute {
            background: #2a3942;
            color: white;
        }

        .call-btn.mute:active {
            background: #202c33;
        }

        .call-btn.video-off {
            background: #2a3942;
            color: white;
        }

        .call-btn.video-off:active {
            background: #202c33;
        }

        .call-btn.accept {
            background: #00a884;
            color: white;
        }

        .call-btn.accept:active {
            background: #128C7E;
        }

        .call-btn.reject {
            background: #d32f2f;
            color: white;
        }

        .call-btn.reject:active {
            background: #b71c1c;
        }

        .call-btn.sound-off {
            background: #2a3942;
            color: white;
        }

        .call-btn.sound-off:active {
            background: #202c33;
        }

        .call-btn.camera-toggle {
            background: #2a3942;
            color: white;
            display: none;
        }

        .call-btn.camera-toggle:active {
            background: #202c33;
        }

        .incoming-call-modal,
        .outgoing-call-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a3942;
            padding: clamp(24px, 6vw, 30px);
            border-radius: 24px;
            text-align: center;
            z-index: 2003;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            display: none;
            width: min(90%, 380px);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .incoming-call-modal.active,
        .outgoing-call-modal.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .ringing-animation {
            position: relative;
            width: clamp(120px, 30vw, 140px);
            height: clamp(120px, 30vw, 140px);
            margin: 0 auto clamp(16px, 4vw, 20px);
        }

        .ringing-avatar {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(48px, 12vw, 56px);
            color: white;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            background-size: cover;
            background-position: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 4px solid rgba(255, 255, 255, 0.1);
        }

        .ringing-animation::before,
        .ringing-animation::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid #00a884;
            animation: ring 1.5s infinite;
        }

        .ringing-animation::after {
            animation-delay: 0.5s;
        }

        @keyframes ring {
            0% {
                width: 100%;
                height: 100%;
                opacity: 1;
            }

            100% {
                width: 180%;
                height: 180%;
                opacity: 0;
            }
        }

        .incoming-call-buttons,
        .outgoing-call-buttons {
            display: flex;
            gap: clamp(15px, 4vw, 20px);
            margin-top: clamp(24px, 6vw, 30px);
            justify-content: center;
            flex-wrap: wrap;
        }

        .profile-modal-content {
            background: #2a3942;
            padding: clamp(24px, 6vw, 30px);
            border-radius: 24px;
            width: min(90%, 400px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .profile-header {
            text-align: center;
            margin-bottom: clamp(24px, 6vw, 30px);
        }

        .profile-avatar-large {
            width: clamp(120px, 30vw, 140px);
            height: clamp(120px, 30vw, 140px);
            border-radius: 50%;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(48px, 12vw, 56px);
            color: white;
            margin: 0 auto clamp(16px, 4vw, 20px);
            cursor: pointer;
            transition: all 0.3s;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 4px solid rgba(255, 255, 255, 0.1);
        }

        .profile-avatar-large:active {
            transform: scale(0.98);
        }

        .profile-name-display {
            font-size: clamp(20px, 5vw, 24px);
            font-weight: 600;
            margin-bottom: clamp(6px, 1.5vw, 8px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(8px, 2vw, 12px);
        }

        .profile-email {
            color: #8696a0;
            font-size: clamp(14px, 3.5vw, 16px);
        }

        .profile-edit-btn {
            background: transparent;
            border: none;
            color: #53bdeb;
            cursor: pointer;
            font-size: clamp(16px, 4vw, 20px);
            padding: clamp(6px, 1.5vw, 8px);
            border-radius: 50%;
            transition: all 0.2s;
        }

        .profile-edit-btn:active {
            background: rgba(42, 57, 66, 0.8);
            transform: scale(0.95);
        }

        .profile-form input {
            width: 100%;
            padding: clamp(12px, 3vw, 14px);
            margin-bottom: clamp(12px, 3vw, 16px);
            background: #202c33;
            border: 2px solid #3d4b54;
            border-radius: 16px;
            color: #e9edef;
            font-size: clamp(14px, 3.5vw, 16px);
            transition: all 0.3s;
        }

        .profile-form input:focus {
            outline: none;
            border-color: #005c4b;
            box-shadow: 0 0 0 3px rgba(0, 92, 75, 0.2);
        }

        .profile-form-buttons {
            display: flex;
            gap: clamp(10px, 2.5vw, 12px);
            margin-top: clamp(20px, 5vw, 24px);
        }

        .profile-save {
            background: #005c4b;
            color: white;
            box-shadow: 0 4px 16px rgba(0, 92, 75, 0.3);
        }

        .profile-save:active {
            background: #0a7c68;
            transform: translateY(2px);
            box-shadow: 0 2px 8px rgba(0, 92, 75, 0.4);
        }

        .profile-cancel {
            background: #8696a0;
            color: white;
        }

        .profile-cancel:active {
            background: #6a7883;
            transform: translateY(2px);
        }

        .upload-progress {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a3942;
            padding: clamp(20px, 5vw, 24px);
            border-radius: 24px;
            z-index: 3000;
            width: min(90%, 340px);
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: none;
        }

        .upload-progress h4 {
            margin-bottom: clamp(12px, 3vw, 16px);
            color: #e9edef;
            font-size: clamp(16px, 4vw, 18px);
        }

        .upload-file-name {
            font-size: clamp(13px, 3.3vw, 14px);
            color: #8696a0;
            margin-bottom: clamp(10px, 2.5vw, 12px);
            word-break: break-word;
            line-height: 1.4;
        }

        .file-transfer-progress {
            display: flex;
            align-items: center;
            gap: clamp(8px, 2vw, 12px);
            margin-top: clamp(12px, 3vw, 16px);
        }

        .progress-bar {
            flex: 1;
            height: clamp(6px, 1.5vw, 8px);
            background: #2a3942;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00a884, #25D366);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: clamp(11px, 2.8vw, 12px);
            color: #8696a0;
            min-width: clamp(36px, 9vw, 40px);
            text-align: right;
        }

        .large-file-upload {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a3942;
            padding: clamp(20px, 5vw, 24px);
            border-radius: 24px;
            z-index: 3000;
            width: min(90%, 400px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: none;
        }

        .large-file-upload h3 {
            margin-bottom: clamp(12px, 3vw, 16px);
            font-size: clamp(16px, 4vw, 18px);
        }

        .large-file-info {
            margin-bottom: clamp(16px, 4vw, 20px);
        }

        .large-file-name {
            font-size: clamp(14px, 3.5vw, 16px);
            margin-bottom: clamp(6px, 1.5vw, 8px);
            word-break: break-word;
        }

        .large-file-size {
            font-size: clamp(12px, 3vw, 14px);
            color: #8696a0;
            margin-bottom: 4px;
        }

        .large-file-warning {
            color: #ff9800;
            font-size: clamp(12px, 3vw, 13px);
            margin-top: clamp(6px, 1.5vw, 8px);
            display: flex;
            align-items: center;
            gap: clamp(4px, 1vw, 6px);
        }

        .large-file-chunks {
            margin-top: clamp(12px, 3vw, 16px);
        }

        .chunk-info {
            font-size: clamp(11px, 2.8vw, 12px);
            color: #8696a0;
            margin-top: clamp(6px, 1.5vw, 8px);
        }

        .network-status {
            position: fixed;
            top: max(env(safe-area-inset-top, 0px), 10px);
            right: 10px;
            background: rgba(42, 57, 66, 0.95);
            padding: clamp(8px, 2vw, 10px) clamp(10px, 2.5vw, 16px);
            border-radius: 20px;
            font-size: clamp(12px, 3vw, 13px);
            display: flex;
            align-items: center;
            gap: clamp(4px, 1vw, 8px);
            z-index: 3000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }

        .network-status.online {
            color: #00a884;
        }

        .network-status.offline {
            color: #ff6b6b;
        }

        .toast-notification {
            position: fixed;
            bottom: max(env(safe-area-inset-bottom, 0px) + 20px, 20px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 168, 132, 0.95);
            color: white;
            padding: clamp(12px, 3vw, 14px) clamp(20px, 5vw, 28px);
            border-radius: 30px;
            z-index: 2001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            animation: slideUp 0.3s ease;
            font-size: clamp(14px, 3.5vw, 15px);
            text-align: center;
            max-width: min(90%, 400px);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toast-notification.error {
            background: rgba(211, 47, 47, 0.95);
        }

        .toast-notification.warning {
            background: rgba(255, 152, 0, 0.95);
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1vw, 6px);
            padding: clamp(10px, 2.5vw, 12px);
            background: rgba(32, 44, 51, 0.95);
            border-radius: 24px;
            width: fit-content;
            margin: 5px 0;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .typing-dot {
            width: clamp(6px, 1.5vw, 8px);
            height: clamp(6px, 1.5vw, 8px);
            background: #8696a0;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {

            0%,
            60%,
            100% {
                transform: translateY(0);
            }

            30% {
                transform: translateY(-5px);
            }
        }

        .swipe-hint {
            position: fixed;
            bottom: max(env(safe-area-inset-bottom, 0px) + 80px, 80px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(42, 57, 66, 0.9);
            padding: clamp(10px, 2.5vw, 12px) clamp(16px, 4vw, 20px);
            border-radius: 20px;
            font-size: clamp(13px, 3.3vw, 14px);
            color: #8696a0;
            display: flex;
            align-items: center;
            gap: clamp(6px, 1.5vw, 8px);
            z-index: 100;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            animation: fadeIn 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .deleted-message {
            color: #8696a0;
            font-style: italic;
            opacity: 0.7;
        }

        .deleted-message .message-content {
            font-style: italic;
        }

        .remote-video-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
            display: none;
        }

        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .local-video-container {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: min(150px, 40vw);
            height: min(200px, 53vw);
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid #005c4b;
            display: none;
            z-index: 2001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .local-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .message.selected {
            background: rgba(0, 168, 132, 0.3) !important;
            border-color: #00a884;
        }

        .message-copy-success {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 168, 132, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            white-space: nowrap;
            animation: fadeOut 2s ease forwards;
        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
            }

            70% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        .performance-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            z-index: 9999;
            display: none;
        }

        @media (min-width: 768px) {
            .app-container {
                display: flex;
                flex-direction: row;
            }

            .sidebar {
                width: min(400px, 35%);
                min-width: 350px;
                position: relative;
                transform: translateX(0) !important;
            }

            .sidebar.hidden {
                transform: translateX(0) !important;
            }

            .chat-area {
                position: relative;
                transform: translateX(0) !important;
            }

            .chat-area.active {
                display: flex;
                transform: translateX(0) !important;
            }

            .back-to-chats {
                display: none !important;
            }

            .emoji-picker-container {
                width: auto;
                max-width: 300px;
            }

        }

        @media (max-width: 320px) {
            .chat-avatar {
                width: 44px;
                height: 44px;
                font-size: 16px;
            }

            .chat-name {
                font-size: 14px;
            }

            .message {
                max-width: 85%;
            }

            .call-btn {
                width: 56px;
                height: 56px;
                font-size: 22px;
            }

            .incoming-call-buttons {
                gap: 16px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .user-info {
                height: 50px;
                padding: 8px 12px;
            }

            .message-input-area {
                padding: 8px;
                min-height: 56px;
            }
  

            .search-box {
                padding: 6px;
            }

            .chat-item {
                padding: 8px;
                min-height: 56px;
            }

            .chat-avatar {
                width: 40px;
                height: 40px;
                font-size: 16px;
                margin-right: 8px;
            }

            .chat-name {
                font-size: 14px;
            }

            .messages-container {
                padding: 8px;
            }

            .message-input-area {
                padding: 8px;
                min-height: 56px;
            }

            .call-contact {
                margin-bottom: 20px;
            }

            .call-avatar {
                width: 80px;
                height: 80px;
                font-size: 32px;
                margin-bottom: 12px;
            }

            .call-controls {
                margin-top: 20px;
                gap: 20px;
            }

            .call-btn {
                width: 56px;
                height: 56px;
                font-size: 24px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Audio recording animation */
        .recording-animation {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(211, 47, 47, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: pulse 1s infinite;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            animation: recordingPulse 1s infinite;
        }

        @keyframes recordingPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Floating animation for background */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            background: rgba(0, 168, 132, 0.1);
            border-radius: 50%;
            animation: particleFloat 15s infinite linear;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 0.5;
            }

            90% {
                opacity: 0.5;
            }

            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* ====== RESPONSIVE FIXES ====== */
        @media (min-width: 769px) {
            .app-container {
                display: flex;
                flex-direction: row;
            }

            .sidebar {
                width: 30%;
                min-width: 350px;
                max-width: 450px;
                position: relative;
                transform: none !important;
                z-index: 100;
            }

            .chat-area {
                display: flex !important;
                position: relative;
                left: auto;
                top: auto;
                width: auto;
                height: 100%;
                transform: none !important;
                flex: 1;
                z-index: 200;
                border-left: 1px solid #2f3941;
            }

            .back-to-chats {
                display: none !important;
            }

            .sidebar.hidden {
                transform: none !important;
            }
        }

        /* Mobile specific fixes */
        @media (max-width: 768px) {
            .chat-area.active {
                display: flex;
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 1000;
            }

            .sidebar {
                width: 100vw;
            }
        }


        
    </style>
</head>

<body>
    <!-- Safe Area for Notches -->
    <div class="safe-area-top"></div>

    <!-- Network Status Indicator -->
    <div id="networkStatus" class="network-status online" style="display: none;">
        <i class="fas fa-wifi"></i>
        <span>Connected</span>
    </div>

    <!-- Performance Overlay (Debug) -->
    <div id="performanceOverlay" class="performance-overlay">
        FPS: <span id="fpsCounter">60</span>
    </div>

    <!-- Floating Background Particles -->
    <div class="floating-particles" id="floatingParticles"></div>

    <!-- Audio Elements -->
    <audio id="remoteAudio" autoplay></audio>
    <audio id="messageSound" style="display: none;"></audio>
    <audio id="ringtoneSound" style="display: none;"></audio>

    <!-- Message Context Menu -->
    <div id="messageContextMenu" class="message-context-menu">
        <div class="context-menu-item copy" onclick="copyMessageText()">
            <i class="fas fa-copy"></i>
            <span>Copy</span>
        </div>
        <div class="context-menu-item reply" onclick="replyToMessage()">
            <i class="fas fa-reply"></i>
            <span>Reply</span>
        </div>
        <div class="context-menu-item forward" onclick="forwardMessage()">
            <i class="fas fa-share"></i>
            <span>Forward</span>
        </div>
        <div class="context-menu-item delete" onclick="deleteMessageFromContext()">
            <i class="fas fa-trash-alt"></i>
            <span>Delete</span>
        </div>
    </div>

    <!-- Status Viewer Modal -->
    <div id="statusModal" class="status-modal">
        <div class="status-progress-bar" id="statusProgressBar"></div>
        <div class="status-viewer-header">
            <div class="chat-avatar" id="statusViewAvatar"></div>
            <div class="status-view-info">
                <h3 id="statusViewName" style="margin: 0; font-size: 16px;">User</h3>
                <span id="statusViewTime" style="font-size: 12px; opacity: 0.8;">10 min ago</span>
            </div>
            <div class="status-actions">
                <i class="fas fa-trash-alt" id="statusDeleteBtn" style="display: none; cursor: pointer;"
                    onclick="deleteCurrentStatus()" title="Delete"></i>
                <i class="fas fa-times" style="cursor: pointer;" onclick="closeStatusModal()" title="Close"></i>
            </div>
        </div>
        <div class="status-content-view" id="statusContentView">
        </div>
        <div class="status-footer" id="statusFooter"
            style="position: absolute; bottom: 0; width: 100%; padding: 20px; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); display: flex; justify-content: center; gap: 20px; align-items: center; z-index: 5002;">
            <div id="statusViewsContainer"
                style="color: white; font-size: 14px; display: none; align-items: center; gap: 8px;">
                <i class="fas fa-eye"></i> <span id="statusViewCount">0</span>
            </div>
            <div id="statusLikeContainer" style="display: none;">
                <button onclick="toggleLikeStatus()" class="status-action-btn"
                    style="background: transparent; border: none; color: white; font-size: 24px; cursor: pointer; transition: transform 0.2s;">
                    <i class="far fa-heart" id="statusLikeIcon"></i>
                </button>
            </div>
        </div>
    </div>


    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-header-top">
                <i class="fas fa-arrow-left" onclick="hideSettings()"
                    style="cursor: pointer; color: #aebac1; font-size: 20px;"></i>
                <h3>Settings</h3>
            </div>
            <div class="settings-body">
                <div class="settings-profile-preview" onclick="showProfile()">
                    <div id="settingsUserAvatar" class="settings-avatar"></div>
                    <div class="settings-text">
                        <h4 id="settingsUserName">User Name</h4>
                        <p id="settingsUserStatus">Available</p>
                    </div>
                </div>

                <div class="settings-item" onclick="showProfile()">
                    <div class="settings-icon"><i class="fas fa-user"></i></div>
                    <div class="settings-text">
                        <h4>Account</h4>
                        <p>Privacy, security, change number</p>
                    </div>
                </div>

                <div class="settings-item" onclick="showToast('Not available on Web Clone', 'info')">
                    <div class="settings-icon"><i class="fas fa-comment-dots"></i></div>
                    <div class="settings-text">
                        <h4>Chats</h4>
                        <p>Theme, wallpapers, chat history</p>
                    </div>
                </div>

                <div class="settings-item" onclick="showToast('Notifications are on', 'info')">
                    <div class="settings-icon"><i class="fas fa-bell"></i></div>
                    <div class="settings-text">
                        <h4>Notifications</h4>
                        <p>Message, group & call tones</p>
                    </div>
                </div>

                <div class="settings-item" onclick="showToast('Storage & Data', 'info')">
                    <div class="settings-icon"><i class="fas fa-circle-notch"></i></div>
                    <div class="settings-text">
                        <h4>Storage and data</h4>
                        <p>Network usage, auto-download</p>
                    </div>
                </div>

                <div class="settings-item" onclick="showToast('Help center', 'info')">
                    <div class="settings-icon"><i class="fas fa-question-circle"></i></div>
                    <div class="settings-text">
                        <h4>Help</h4>
                        <p>Help centre, contact us, privacy policy</p>
                    </div>
                </div>

                <div class="settings-item" style="color: #ef4444;" onclick="logout()">
                    <div class="settings-icon"><i class="fas fa-sign-out-alt" style="color: #ef4444;"></i></div>
                    <div class="settings-text">
                        <h4 style="color: #ef4444;">Logout</h4>
                        <p>Sign out of your account</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Group Creation Modal -->
    <div id="groupCreationModal" class="modal-overlay group-creation-modal">
        <div class="modal-content">
            <h3>Create New Group</h3>
            <div class="form-group">
                <input type="text" id="groupNameInput" placeholder="Group Name" class="group-creation-input">
            </div>
            <div class="group-avatar-preview" id="groupAvatarPreview">
                <i class="fas fa-users"></i>
            </div>

            <div class="group-creation-stats">
                <div class="stat">
                    <div class="stat-value" id="selectedMembersCount">0</div>
                    <div class="stat-label">Members</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="groupNameLength">0</div>
                    <div class="stat-label">Chars</div>
                </div>
            </div>

            <div class="search-box" style="background: transparent; padding: 10px 0;">
                <input type="text" id="groupMemberSearch" placeholder="Search contacts to add..."
                    class="group-creation-input">
            </div>
            <div class="group-members-list" id="groupMembersList">
                <!-- Group members will be listed here -->
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeGroupCreationModal()">Cancel</button>
                <button class="profile-save" onclick="createNewGroup()" id="createGroupBtn" disabled>Create
                    Group</button>
            </div>
        </div>
    </div>

    <!-- ====== AUTH CONTAINER ====== -->
    <div id="authContainer" class="auth-container">
        <div id="loginForm" class="auth-form active">
            <h2>Welcome to WebChat</h2>
            <div class="form-group">
                <input type="email" id="loginEmail" placeholder="Email" autocomplete="email">
                <i class="fas fa-envelope input-icon"></i>
            </div>
            <div class="form-group" style="position: relative;">
                <input type="password" id="loginPassword" placeholder="Password" autocomplete="current-password">
                <i class="fas fa-lock input-icon"></i>
                <button type="button" class="password-toggle" onclick="togglePasswordVisibility()" style="position: absolute; right: 40px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #8696a0; cursor: pointer; font-size: 18px; padding: 5px; transition: all 0.3s;">
                    <i class="fas fa-eye" id="passwordEyeIcon"></i>
                </button>
            </div>
            <div class="form-group" style="margin-bottom: 20px;">
                <label for="rememberMe" class="remember-toggle">
                    <input type="checkbox" id="rememberMe" style="display: none;">
                    <span class="toggle-slider"></span>
                    <span class="toggle-text">Remember me</span>
                </label>
            </div>
            <button class="auth-btn" onclick="login()" id="loginButton">
                <div class="loader"></div>
                <span class="btn-text">Login</span>
                <i class="fas fa-arrow-right btn-icon"></i>
            </button>
            <div class="auth-switch">
                New user? <span class="switch-link" onclick="showSignup()">Create Account</span>
            </div>
            <div class="auth-features">
                <div class="feature">
                    <i class="fas fa-video"></i>
                    <span>Video Calls</span>
                </div>
                <div class="feature">
                    <i class="fas fa-lock"></i>
                    <span>Secure</span>
                </div>
                <div class="feature">
                    <i class="fas fa-bolt"></i>
                    <span>Fast</span>
                </div>
            </div>
        </div>

        <div id="signupForm" class="auth-form">
            <h2>Join WebChat</h2>
            <div class="form-group">
                <input type="text" id="signupName" placeholder="Full Name">
                <i class="fas fa-user input-icon"></i>
            </div>
            <div class="form-group">
                <input type="email" id="signupEmail" placeholder="Email" autocomplete="email">
                <i class="fas fa-envelope input-icon"></i>
            </div>
            <div class="form-group">
                <input type="password" id="signupPassword" placeholder="Password" autocomplete="new-password">
                <i class="fas fa-lock input-icon"></i>
            </div>
            <div class="form-group">
                <input type="password" id="signupConfirmPassword" placeholder="Confirm Password">
                <i class="fas fa-lock input-icon"></i>
            </div>
            <button class="auth-btn" onclick="signup()" id="signupButton">
                <div class="loader"></div>
                <span class="btn-text">Sign Up</span>
                <i class="fas fa-user-plus btn-icon"></i>
            </button>
            <div class="auth-switch">
                Already have an account? <span class="switch-link" onclick="showLogin()">Login Here</span>
            </div>
        </div>

        <!-- Animation Elements -->
        <div class="floating-animation">
            <div class="floating-icon"><i class="fas fa-comment"></i></div>
            <div class="floating-icon"><i class="fas fa-phone"></i></div>
            <div class="floating-icon"><i class="fas fa-video"></i></div>
        </div>
    </div>

    <!-- ====== MAIN APP CONTAINER ====== -->
    <div id="appContainer" class="app-container" style="display: none;">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="user-info">
                <div class="app-title">
                    <i class="fas fa-comment-dots"></i>
                    <span>WebChat</span>
                </div>
                <div class="user-actions">
                    <i class="fas fa-circle-notch" title="Status" onclick="toggleStatusView()"></i>
                    <i class="fas fa-users" title="New Group" onclick="showNewGroupModal()"></i>
                    <i class="fas fa-ellipsis-v" title="Menu" id="menuToggle"></i>
                    <div class="menu-dropdown" id="menuDropdown">
                        <div class="menu-item" onclick="showProfileModal()">
                            <i class="fas fa-user"></i>
                            <span>Profile</span>
                        </div>
                        <div class="menu-item" onclick="showSettings()">
                            <i class="fas fa-cog"></i>
                            <span>Settings</span>
                        </div>
                        <div class="menu-item" onclick="showArchivedChats()">
                            <i class="fas fa-archive"></i>
                            <span>Archived Chats</span>
                        </div>
                        <div class="menu-item" onclick="showStarredMessages()">
                            <i class="fas fa-star"></i>
                            <span>Starred Messages</span>
                        </div>
                        <div class="menu-item logout" onclick="logout()">
                            <i class="fas fa-sign-out-alt"></i>
                            <span>Logout</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="search-box">
                <input type="text" id="searchUser" placeholder="Search or start new chat" oninput="searchUsers()">
            </div>
            <div class="chat-list" id="chatList">
                <!-- Chat items will be added here dynamically -->
            </div>

            <!-- Status View -->
            <div class="status-view" id="statusView">
                <div class="status-header">
                    <div class="status-back-btn" onclick="toggleStatusView()">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <h2>Status</h2>
                </div>
                <div class="my-status-section">
                    <div class="status-avatar-wrapper" onclick="handleMyStatusClick()">
                        <div class="status-ring" id="myStatusRing" style="display: none;"></div>
                        <div class="status-avatar" id="myStatusAvatar"></div>
                        <div class="add-status-icon">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    <div class="status-info" onclick="handleMyStatusClick()">
                        <h3>My Status</h3>
                        <p id="myStatusTime">Click to add status update</p>
                    </div>
                    <div id="myStatusDeleteBtn" class="my-status-delete-sidebar" style="display: none;"
                        onclick="showMyStatusManagement()">
                        <i class="fas fa-ellipsis-v"></i>
                    </div>
                    <input type="file" id="statusUploadInput" class="status-upload-input" accept="image/*,video/*"
                        multiple>
                </div>
                <div class="recent-updates-title">Recent updates</div>
                <div id="statusList">
                    <!-- Status items -->
                </div>
            </div>
        </div> <!-- end sidebar -->

        <!-- Chat Area -->
        <div class="chat-area" id="chatArea">
            <div class="chat-header-area">
                <div class="back-to-chats" onclick="showChatList()">
                    <i class="fas fa-arrow-left"></i>
                </div>
                <div class="chat-contact">
                    <div class="avatar-container">
                        <div class="user-avatar" id="contactAvatar">C</div>
                        <div class="online-dot" id="onlineDot" style="display: none;"></div>
                    </div>
                    <div>
                        <div class="chat-contact-name" id="contactName">Select a chat</div>
                        <div class="chat-contact-status" id="contactStatus">Click on a chat to start messaging</div>
                    </div>
                </div>
                <div class="chat-actions">
                    <i class="fas fa-phone-alt" title="Voice Call" onclick="startAudioCall()"></i>
                    <i class="fas fa-video" title="Video Call" onclick="startVideoCall()"></i>
                    <i class="fas fa-ellipsis-v" title="Menu" onclick="toggleChatMenu()"></i>
                </div>
            </div>

            <div class="messages-container" id="messagesContainer">
                <!-- Messages will load here -->
                <div class="empty-chat">
                    <div class="empty-chat-icon">
                        <i class="fas fa-comment-slash"></i>
                    </div>
                    <h3>No chat selected</h3>
                    <p>Select a chat from the list or search for a user to start messaging.</p>
                </div>
            </div>

            <div class="message-input-area">
                <div id="replyPreview" class="reply-preview-container">
                    <div class="reply-preview-header">
                        <span id="replySender" class="reply-preview-sender">User Name</span>
                        <i class="fas fa-times reply-preview-close" onclick="cancelReply()"></i>
                    </div>
                    <div id="replyText" class="reply-preview-text">Replied message text goes here...</div>
                </div>
                <div class="input-main-row">
                    <div class="input-actions" style="margin-right: 0;">
                        <i class="far fa-smile" id="emojiButton" onclick="toggleEmojiPicker()"></i>
                        <i class="fas fa-paperclip" id="attachmentButton" onclick="toggleAttachmentMenu()"></i>
                        <div class="attachment-menu" id="attachmentMenu">
                            <div class="attachment-option" onclick="attachImage()">
                                <i class="fas fa-image"></i>
                                <span>Photo & Video</span>
                            </div>
                            <div class="attachment-option" onclick="attachDocument()">
                                <i class="fas fa-file"></i>
                                <span>Document</span>
                            </div>
                            <div class="attachment-option" onclick="startVoiceRecording()">
                                <i class="fas fa-microphone"></i>
                                <span>Audio</span>
                            </div>
                            <div class="attachment-option" onclick="attachLocation()">
                                <i class="fas fa-map-marker-alt"></i>
                                <span>Location</span>
                            </div>
                            <div class="attachment-option" onclick="attachContact()">
                                <i class="fas fa-user-plus"></i>
                                <span>Contact</span>
                            </div>
                        </div>
                        <div class="emoji-picker-container" id="emojiPickerContainer"></div>
                    </div>
                    <div class="input-wrapper">
                        <input type="text" id="messageInput" placeholder="Type a message"
                            onkeypress="handleKeyPress(event)" oninput="handleTyping()">
                        <i class="fas fa-microphone" id="micButton" onclick="startVoiceMessage()"
                            style="display: none;"></i>
                    </div>
                    <div class="send-button" onclick="sendMessage()" id="sendButton">
                        <i class="fas fa-paper-plane"></i>
                    </div>
                    <div class="send-button" onclick="stopVoiceRecording()" id="stopVoiceButton"
                        style="display: none; background: #d32f2f;">
                        <i class="fas fa-stop"></i>
                    </div>
                </div>
            </div>
            <div class="safe-area-bottom"></div>
        </div>
    </div>

    <!-- ====== MODALS ====== -->

    <!-- Delete Message Modal -->
    <div id="deleteModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Delete Message</h3>
            <p id="deleteModalText">Select how you want to delete this message:</p>

            <div class="delete-options">
                <div class="delete-option" id="deleteForEveryone" onclick="selectDeleteOption('everyone')">
                    <div class="delete-option-title">Delete for Everyone</div>
                    <div class="delete-option-desc">Remove this message for all chat participants. This action
                        cannot be
                        undone.</div>
                </div>
                <div class="delete-option" id="deleteForMe" onclick="selectDeleteOption('me')">
                    <div class="delete-option-title">Delete for Me</div>
                    <div class="delete-option-desc">Remove this message only for you. Others will still see it.
                    </div>
                </div>
            </div>

            <div class="modal-buttons">
                <button class="modal-delete" onclick="confirmDelete()" id="confirmDeleteBtn" disabled>Delete</button>
                <button class="modal-cancel" onclick="cancelDelete()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Delete Chat Modal -->
    <div id="deleteChatModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Delete Chat</h3>
            <div class="chat-delete-confirm">
                <p>Are you sure you want to delete this chat?</p>
                <div class="chat-delete-warning">
                    <i class="fas fa-exclamation-triangle"></i>
                    This action cannot be undone
                </div>
            </div>

            <div class="modal-buttons">
                <button class="modal-delete" onclick="confirmChatDelete()">Delete Chat</button>
                <button class="modal-cancel" onclick="cancelChatDelete()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Forward Message Modal -->
<!-- Forward Message Modal -->
<div id="forwardModal" class="modal-overlay">
    <div class="modal-content" style="max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
        <h3 style="margin-bottom: 10px; flex-shrink: 0;">Forward message to</h3>
        <div class="search-box" style="margin-bottom: 10px; padding: 8px 0; flex-shrink: 0;">
            <input type="text" id="forwardSearch" placeholder="Search contacts..."
                oninput="filterForwardContacts()" style="width: 100%; padding: 12px 16px;">
        </div>
        <div id="forwardContactList" class="group-members-list" 
             style="flex: 1; overflow-y: auto; min-height: 200px; max-height: 50vh;">
            <!-- Contacts will be loaded here -->
        </div>
        <div class="modal-buttons" style="margin-top: 15px; flex-shrink: 0;">
            <button class="modal-cancel" onclick="closeForwardModal()">Cancel</button>
        </div>
    </div>
</div>

    <!-- Profile Modal -->
    <div id="profileModal" class="modal-overlay">
        <div class="profile-modal-content">
            <div class="profile-header">
                <div class="profile-avatar-large" id="profileAvatarLarge" onclick="changeProfilePicture()">
                    <span id="profileAvatarText">U</span>
                    <div class="camera-icon">
                        <i class="fas fa-camera"></i>
                    </div>
                </div>
                <div class="profile-name-display" id="profileNameDisplay">
                    <span id="profileNameText">User</span>
                    <button class="profile-edit-btn" onclick="enableProfileEdit()">
                        <i class="fas fa-edit"></i>
                    </button>
                </div>
                <div class="profile-email" id="profileEmailText">user@example.com</div>
            </div>

            <div class="profile-form" id="profileForm" style="display: none;">
                <input type="text" id="profileNameInput" placeholder="Enter your name">
                <input type="email" id="profileEmailInput" placeholder="Enter your email" readonly>
                <div class="profile-form-buttons">
                    <button class="profile-save" onclick="saveProfile()">Save Changes</button>
                    <button class="profile-cancel" onclick="cancelProfileEdit()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Picture Upload -->
    <div id="profileUploadModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Change Profile Picture</h3>
            <div class="upload-options" style="margin-top: 20px;">
                <div class="attachment-option" onclick="uploadProfilePictureFromGallery()">
                    <i class="fas fa-images"></i>
                    <span>Choose from Gallery</span>
                </div>
                <div class="attachment-option" onclick="takeProfilePicture()">
                    <i class="fas fa-camera"></i>
                    <span>Take Photo</span>
                </div>
                <div class="attachment-option" onclick="removeProfilePicture()" style="color: #ff6b6b;">
                    <i class="fas fa-trash"></i>
                    <span>Remove Picture</span>
                </div>
            </div>
            <div class="modal-buttons" style="margin-top: 30px;">
                <button class="modal-cancel" onclick="closeProfileUpload()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Call Interface -->
    <audio id="ringtoneSound" loop></audio>
    <div id="callInterface" class="call-interface">
        <div id="videoGrid" class="video-grid" style="display: none;"></div>
        <div class="remote-video-container" id="remoteVideoContainer">
            <video class="remote-video" id="remoteVideo" autoplay playsinline></video>
        </div>
        <div class="local-video-container" id="localVideoContainer">
            <video class="local-video" id="localVideo" autoplay playsinline muted></video>
        </div>
        <div class="call-contact" id="callContactInfo">
            <div class="call-avatar" id="callAvatar">C</div>
            <div class="call-status" id="callStatus">Calling...</div>
            <div class="call-timer" id="callTimer"></div>
        </div>
        <div class="call-controls">
            <div class="call-btn mute" onclick="toggleMute()">
                <i class="fas fa-microphone-slash" id="muteIcon"></i>
            </div>
            <div class="call-btn hangup" onclick="endCall()">
                <i class="fas fa-phone-slash"></i>
            </div>
            <div class="call-btn video-off" onclick="toggleVideo()">
                <i class="fas fa-video-slash" id="videoIcon"></i>
            </div>
            <!-- Camera Toggle Button -->
            <div class="call-btn camera-toggle" onclick="toggleCamera()" id="cameraToggleBtn" style="display: none;">
                <i class="fas fa-camera-rotate" id="cameraToggleIcon"></i>
            </div>
        </div>
        <!-- Floating Camera Toggle Button -->
        <div class="camera-toggle-btn" onclick="toggleCamera()" id="floatingCameraToggle" style="display: none;">
            <i class="fas fa-camera-rotate"></i>
        </div>
    </div>

    <!-- Incoming Call Modal -->
    <div id="incomingCallModal" class="incoming-call-modal">
        <div class="ringing-animation">
            <div class="ringing-avatar" id="incomingCallAvatar">C</div>
        </div>
        <h3 id="incomingCallName">Incoming Call</h3>
        <p id="incomingCallType">Voice Call</p>
        <div class="incoming-call-buttons">
            <div class="call-btn accept" onclick="acceptCall()">
                <i class="fas fa-phone-alt"></i>
            </div>
            <div class="call-btn reject" onclick="rejectCall()">
                <i class="fas fa-phone-slash"></i>
            </div>
        </div>
    </div>

    <!-- Outgoing Call Modal -->
    <div id="outgoingCallModal" class="outgoing-call-modal">
        <div class="ringing-animation">
            <div class="ringing-avatar" id="outgoingCallAvatar">C</div>
        </div>
        <h3 id="outgoingCallName">Calling...</h3>
        <p id="outgoingCallType">Voice Call</p>
        <div class="outgoing-call-buttons">
            <div class="call-btn hangup" onclick="cancelOutgoingCall()">
                <i class="fas fa-phone-slash"></i>
            </div>
        </div>
    </div>

    <!-- Location Picker with Satellite View -->
    <div id="locationPickerModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Share Location</h3>

            <div class="satellite-view" id="satelliteView">
                <div class="satellite-loading">
                    <div class="spinner"></div>
                    <p>Loading satellite view...</p>
                </div>
            </div>

            <div class="location-controls">
                <button class="satellite-btn" onclick="toggleSatelliteView()">
                    <i class="fas fa-satellite"></i> Satellite
                </button>
                <button class="refresh-btn" onclick="refreshLocation()">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>

            <div style="margin-top: 20px;">
                <input type="text" id="locationSearch" placeholder="Search for a place or address"
                    style="width: 100%; padding: 12px; background: #202c33; border: 1px solid #3d4b54; border-radius: 12px; color: #e9edef; margin-bottom: 12px;">
            </div>

            <div class="modal-buttons">
                <button class="modal-cancel" onclick="useCurrentLocation()">
                    <i class="fas fa-location-arrow"></i> Current Location
                </button>
                <button class="profile-save" onclick="sendLocation()">
                    <i class="fas fa-paper-plane"></i> Send Location
                </button>
            </div>
            <div class="modal-buttons" style="margin-top: 12px;">
                <button class="modal-cancel" onclick="closeLocationPicker()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- File Upload Progress -->
    <div id="uploadProgressModal" class="upload-progress">
        <h4>Sending File</h4>
        <div class="upload-file-name" id="uploadFileName"></div>
        <div class="file-transfer-progress">
            <div class="progress-bar">
                <div class="progress-fill" style="width: 0%" id="uploadProgressFill"></div>
            </div>
            <div class="progress-text" id="uploadProgressText">0%</div>
        </div>
        <div class="file-size-warning" id="uploadFileWarning" style="display: none;">
            <i class="fas fa-info-circle"></i>
            Large file - this may take a moment
        </div>
    </div>

    <!-- Large File Upload -->
    <div id="largeFileUploadModal" class="large-file-upload">
        <h3>Large File Upload</h3>
        <div class="large-file-info">
            <div class="large-file-name" id="largeFileName"></div>
            <div class="large-file-size" id="largeFileSize"></div>
            <div class="large-file-warning" id="largeFileWarning">
                <i class="fas fa-exclamation-triangle"></i>
                This file is large and will be sent using WebRTC DataChannel
            </div>
        </div>
        <div class="file-transfer-progress">
            <div class="progress-bar">
                <div class="progress-fill" style="width: 0%" id="largeFileProgressFill"></div>
            </div>
            <div class="progress-text" id="largeFileProgressText">0%</div>
        </div>
        <div class="large-file-chunks">
            <div class="chunk-info" id="chunkInfo">Establishing WebRTC connection...</div>
        </div>
        <div class="modal-buttons" style="margin-top: 20px;">
            <button class="modal-cancel" onclick="cancelLargeFileUpload()">Cancel</button>
        </div>
    </div>

    <!-- Large File Download Progress -->
    <div id="largeFileDownloadModal" class="modal-overlay">
        <div class="upload-progress">
            <h4>Downloading File</h4>
            <div class="upload-file-name" id="downloadFileName"></div>
            <div class="file-transfer-progress">
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 0%" id="downloadProgressFill"></div>
                </div>
                <div class="progress-text" id="downloadProgressText">0%</div>
            </div>
            <div class="file-size-warning">
                <i class="fas fa-info-circle"></i>
                Large file - please wait
            </div>
            <div class="chunk-info" id="downloadChunkInfo">Processing chunks...</div>
        </div>
    </div>

    <!-- Recording Animation -->
    <div id="recordingAnimation" class="recording-animation" style="display: none;">
        <div class="recording-dot"></div>
        <span>Recording...</span>
    </div>

    <!-- Swipe Hint -->
    <div class="swipe-hint" id="swipeHint" style="display: none;">
        <i class="fas fa-arrow-right"></i>
        <span>Swipe right to go back</span>
    </div>

    <!-- ====== FIREBASE AND PEERJS SCRIPTS ====== -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            updateDoc,
            deleteDoc,
            doc,
            setDoc,
            getDoc,
            getDocs,
            query,
            where,
            orderBy,
            onSnapshot,
            serverTimestamp,
            arrayUnion,
            arrayRemove,
            limit,
            increment,
            Timestamp
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAUMzprqibG6kgU0T86RAu2Z5UB527q9PQ",
            authDomain: "web-738ee.firebaseapp.com",
            projectId: "web-738ee",
            storageBucket: "web-738ee.firebasestorage.app",
            messagingSenderId: "27451314930",
            appId: "1:27451314930:web:72a992a73dd8294050766b"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // PeerJS Configuration
        let peer = null;
        let currentPeerId = null;
        let activeCall = null;
        let localStream = null;
        let remoteStream = null;
        let callInitiator = false;
        let incomingCallData = null;
        let outgoingCallData = null;

        // App State
        let currentUser = null;
        let currentChatId = null;
        let currentContact = null;
        let messageUnsubscribe = null;
        let chatsUnsubscribe = null;
        let messageToDelete = null;
        let deleteOption = null;
        let currentMessageData = null;
        let isTypingTimeout = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let callTimer = null;
        let callStartTime = null;
        let isInCall = false;
        let isMuted = false;
        let isVideoOff = false;
        let currentCallType = null;
        let outgoingCallTimeout = null;
        let currentCamera = 'user';
        let chatToDelete = null;
        let activeFileTransfers = new Map();
        let chatCache = new Map();
        let replyingTo = null; // State for reply feature

        // Enhanced state
        let userProfilePicture = null;
        let currentLocation = null;
        let largeFileUpload = null;
        let locationPickerActive = false;
        let activeCallConnections = new Set();
        let messageContextMenuActive = false;
        let selectedMessageId = null;
        let selectedMessageText = null;
        let lastClickTime = 0;
        let clickDebounce = false;

        // WebRTC DataChannel for file transfer
        let dataChannel = null;
        let fileTransferConnections = new Map();
        let pendingFileTransfers = new Map();

        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;

        // Long press variables
        let longPressTimer = null;
        let isLongPress = false;
        let longPressMessageId = null;

        // Forward message state
        let messageToForward = null;
        let forwardToContact = null;

        // Group chat state
        let currentGroupId = null;
        let currentGroupMembers = [];
        let selectedGroupMembers = new Set();

        // Camera state
        let availableCameras = [];

        // Ringtone state
        let ringtoneInterval = null;
        let isRinging = false;

        // DOM Elements
        const authContainer = document.getElementById('authContainer');
        const appContainer = document.getElementById('appContainer');
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const chatList = document.getElementById('chatList');
        const messagesContainer = document.getElementById('messagesContainer');
        const messageInput = document.getElementById('messageInput');
        const userAvatar = document.querySelector('.user-avatar');
        const contactName = document.getElementById('contactName');
        const contactAvatar = document.getElementById('contactAvatar');
        const contactStatus = document.getElementById('contactStatus');
        const chatArea = document.getElementById('chatArea');
        const onlineDot = document.getElementById('onlineDot');
        const searchInput = document.getElementById('searchUser');
        const deleteModal = document.getElementById('deleteModal');
        const deleteModalText = document.getElementById('deleteModalText');
        const deleteChatModal = document.getElementById('deleteChatModal');
        const menuToggle = document.getElementById('menuToggle');
        const menuDropdown = document.getElementById('menuDropdown');
        const deleteForEveryone = document.getElementById('deleteForEveryone');
        const deleteForMe = document.getElementById('deleteForMe');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        const emojiButton = document.getElementById('emojiButton');
        const emojiPickerContainer = document.getElementById('emojiPickerContainer');
        const attachmentButton = document.getElementById('attachmentButton');
        const attachmentMenu = document.getElementById('attachmentMenu');
        const callInterface = document.getElementById('callInterface');
        const callAvatar = document.getElementById('callAvatar');
        const callStatus = document.getElementById('callStatus');
        const callTimerElement = document.getElementById('callTimer');
        const micButton = document.getElementById('micButton');
        const sendButton = document.getElementById('sendButton');
        const stopVoiceButton = document.getElementById('stopVoiceButton');
        const incomingCallModal = document.getElementById('incomingCallModal');
        const incomingCallAvatar = document.getElementById('incomingCallAvatar');
        const incomingCallName = document.getElementById('incomingCallName');
        const incomingCallType = document.getElementById('incomingCallType');
        const outgoingCallModal = document.getElementById('outgoingCallModal');
        const outgoingCallAvatar = document.getElementById('outgoingCallAvatar');
        const outgoingCallName = document.getElementById('outgoingCallName');
        const outgoingCallType = document.getElementById('outgoingCallType');
        const remoteVideo = document.getElementById('remoteVideo');
        const remoteVideoContainer = document.getElementById('remoteVideoContainer');
        const localVideo = document.getElementById('localVideo');
        const localVideoContainer = document.getElementById('localVideoContainer');
        const callContactInfo = document.getElementById('callContactInfo');
        const remoteAudio = document.getElementById('remoteAudio');
        const profileModal = document.getElementById('profileModal');
        const profileAvatarLarge = document.getElementById('profileAvatarLarge');
        const profileAvatarText = document.getElementById('profileAvatarText');
        const profileNameDisplay = document.getElementById('profileNameDisplay');
        const profileNameText = document.getElementById('profileNameText');
        const profileEmailText = document.getElementById('profileEmailText');
        const profileForm = document.getElementById('profileForm');
        const profileNameInput = document.getElementById('profileNameInput');
        const profileEmailInput = document.getElementById('profileEmailInput');
        const networkStatus = document.getElementById('networkStatus');
        const uploadProgressModal = document.getElementById('uploadProgressModal');
        const uploadFileName = document.getElementById('uploadFileName');
        const replyPreview = document.getElementById('replyPreview');
        const replySender = document.getElementById('replySender');
        const replyTextEl = document.getElementById('replyText');
        const forwardModal = document.getElementById('forwardModal');
        const uploadProgressFill = document.getElementById('uploadProgressFill');
        const uploadProgressText = document.getElementById('uploadProgressText');
        const locationPickerModal = document.getElementById('locationPickerModal');
        const locationSearch = document.getElementById('locationSearch');
        const profileUploadModal = document.getElementById('profileUploadModal');
        const largeFileUploadModal = document.getElementById('largeFileUploadModal');
        const largeFileName = document.getElementById('largeFileName');
        const largeFileSize = document.getElementById('largeFileSize');
        const largeFileProgressFill = document.getElementById('largeFileProgressFill');
        const largeFileProgressText = document.getElementById('largeFileProgressText');
        const chunkInfo = document.getElementById('chunkInfo');
        const sidebar = document.getElementById('sidebar');
        const swipeHint = document.getElementById('swipeHint');
        const messageContextMenu = document.getElementById('messageContextMenu');
        const performanceOverlay = document.getElementById('performanceOverlay');
        const fpsCounter = document.getElementById('fpsCounter');
        const messageSound = document.getElementById('messageSound');
        const ringtoneSound = document.getElementById('ringtoneSound');
        const largeFileDownloadModal = document.getElementById('largeFileDownloadModal');
        const downloadFileName = document.getElementById('downloadFileName');
        const downloadProgressFill = document.getElementById('downloadProgressFill');
        const downloadProgressText = document.getElementById('downloadProgressText');
        const downloadChunkInfo = document.getElementById('downloadChunkInfo');
        const forwardSearch = document.getElementById('forwardSearch');
        const forwardContactList = document.getElementById('forwardContactList');
        const confirmForwardBtn = document.getElementById('confirmForwardBtn');
        const loginButton = document.getElementById('loginButton');
        const signupButton = document.getElementById('signupButton');
        const groupCreationModal = document.getElementById('groupCreationModal');
        const groupNameInput = document.getElementById('groupNameInput');
        const groupAvatarPreview = document.getElementById('groupAvatarPreview');
        const groupMemberSearch = document.getElementById('groupMemberSearch');
        const groupMembersList = document.getElementById('groupMembersList');
        const createGroupBtn = document.getElementById('createGroupBtn');
        const cameraToggleBtn = document.getElementById('cameraToggleBtn');
        const floatingCameraToggle = document.getElementById('floatingCameraToggle');
        const recordingAnimation = document.getElementById('recordingAnimation');
        const floatingParticles = document.getElementById('floatingParticles');
        const selectedMembersCount = document.getElementById('selectedMembersCount');
        const groupNameLength = document.getElementById('groupNameLength');

        // ====== INITIALIZATION ======
        function initFloatingParticles() {
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const size = Math.random() * 20 + 5;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 15}s`;
                particle.style.background = `rgba(${Math.random() * 100}, ${Math.random() * 255}, ${Math.random() * 200}, ${Math.random() * 0.2})`;
                floatingParticles.appendChild(particle);
            }
        }

        // ====== LOADER FUNCTIONS ======
        function showButtonLoader(button, show) {
            const btnText = button.querySelector('.btn-text');
            const btnIcon = button.querySelector('.btn-icon');

            if (show) {
                let loader = button.querySelector('.loader');
                if (!loader) {
                    loader = document.createElement('div');
                    loader.className = 'loader';
                    button.insertBefore(loader, btnText);
                }
                loader.classList.add('active');
                btnText.classList.add('loading');
                btnIcon.style.opacity = '0.5';
                button.disabled = true;
            } else {
                const loader = button.querySelector('.loader');
                if (loader) {
                    loader.classList.remove('active');
                }
                btnText.classList.remove('loading');
                btnIcon.style.opacity = '1';
                button.disabled = false;
            }
        }

        // ====== PERFORMANCE OPTIMIZATION ======
        function startPerformanceMonitor() {
            let fpsWarningThrottled = false;
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    fps = frameCount;
                    frameCount = 0;
                    lastTime = currentTime;

                    if (fps < 30) {
                        // Only log warning once every 5 seconds to reduce console spam
                        if (!fpsWarningThrottled) {
                            console.warn(`Low FPS: ${fps}`);
                            fpsWarningThrottled = true;
                            setTimeout(() => { fpsWarningThrottled = false; }, 5000);
                        }
                        document.body.classList.add('reduce-motion');
                    } else {
                        document.body.classList.remove('reduce-motion');
                    }

                    // Only update display if overlay is visible to reduce DOM manipulation
                    if (performanceOverlay && performanceOverlay.style.display === 'block') {
                        fpsCounter.textContent = fps;
                    }
                }
                requestAnimationFrame(updateFPS);
            }
            updateFPS();
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Password visibility toggle
        window.togglePasswordVisibility = () => {
            const passwordInput = document.getElementById('loginPassword');
            const eyeIcon = document.getElementById('passwordEyeIcon');
            
            if (passwordInput.type === 'password') {
                passwordInput.type = 'text';
                eyeIcon.className = 'fas fa-eye-slash';
            } else {
                passwordInput.type = 'password';
                eyeIcon.className = 'fas fa-eye';
            }
        };

        // ====== AUTH FUNCTIONS ======
        window.showSignup = () => {
            loginForm.classList.remove('active');
            signupForm.classList.add('active');
        };

        window.showLogin = () => {
            signupForm.classList.remove('active');
            loginForm.classList.add('active');
        };

        window.signup = async () => {
            if (clickDebounce) return;
            clickDebounce = true;

            showButtonLoader(signupButton, true);

            const name = document.getElementById('signupName').value.trim();
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;
            const confirmPassword = document.getElementById('signupConfirmPassword').value;

            if (!name || !email || !password || !confirmPassword) {
                showToast('Please fill all fields', 'error');
                showButtonLoader(signupButton, false);
                clickDebounce = false;
                return;
            }

            if (password !== confirmPassword) {
                showToast('Passwords do not match', 'error');
                showButtonLoader(signupButton, false);
                clickDebounce = false;
                return;
            }

            if (password.length < 6) {
                showToast('Password must be at least 6 characters', 'error');
                showButtonLoader(signupButton, false);
                clickDebounce = false;
                return;
            }

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const user = userCredential.user;

                console.log('âœ… Account created:', user.uid);

                await setDoc(doc(db, "users", user.uid), {
                    uid: user.uid,
                    name: name,
                    email: email,
                    avatarColor: getRandomColor(),
                    online: true,
                    lastSeen: serverTimestamp(),
                    lastOnline: serverTimestamp(),
                    createdAt: serverTimestamp(),
                    peerId: ''
                });

                showToast('Account created successfully!');
                showLogin();
            } catch (error) {
                console.error('âŒ Signup error:', error);
                showToast('Error: ' + error.message, 'error');
            } finally {
                showButtonLoader(signupButton, false);
                setTimeout(() => clickDebounce = false, 500);
            }
        };

        window.login = async () => {
            if (clickDebounce) return;
            clickDebounce = true;

            showButtonLoader(loginButton, true);

            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showToast('Please enter email and password', 'error');
                showButtonLoader(loginButton, false);
                clickDebounce = false;
                return;
            }

            try {
                await signInWithEmailAndPassword(auth, email, password);
                // Save email if remember me is checked
                if (document.getElementById('rememberMe').checked) {
                    localStorage.setItem('rememberedEmail', email);
                } else {
                    localStorage.removeItem('rememberedEmail');
                }
            } catch (error) {
                console.error('âŒ Login error:', error);
                showToast('Error: ' + error.message, 'error');
            } finally {
                showButtonLoader(loginButton, false);
                setTimeout(() => clickDebounce = false, 500);
            }
        };

        // Auth State Listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                console.log('âœ… User logged in:', user.uid);
                currentUser = user;
                await loadUserData();
                authContainer.style.display = 'none';
                appContainer.style.display = 'flex';
                loadChats();
                setupTypingListener();
                initializePeer();
                monitorNetworkStatus();
                startPerformanceMonitor();
                initFloatingParticles();
                loadMessages(); // Show 'No chat selected' on desktop start

                const profilePic = await loadProfilePicture(user.uid);
                if (profilePic) {
                    userProfilePicture = profilePic;
                    updateProfilePicture(profilePic);
                }
            } else {
                currentUser = null;
                authContainer.style.display = 'block';
                appContainer.style.display = 'none';
                showLogin();

                if (peer) {
                    try {
                        peer.destroy();
                    } catch (e) {
                        console.log('Error destroying peer:', e);
                    }
                    peer = null;
                }
            }
        });

        // ====== USER DATA FUNCTIONS ======
        async function loadUserData() {
            try {
                const userRef = doc(db, "users", currentUser.uid);
                const userDoc = await getDoc(userRef);

                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    const userName = userData.name || currentUser.email.split('@')[0];

                    if (!userProfilePicture) {
                        userAvatar.textContent = userName.charAt(0).toUpperCase();
                    }
                    userAvatar.style.backgroundColor = userData.avatarColor || '#25D366';

                    await updateDoc(userRef, {
                        online: true,
                        lastSeen: serverTimestamp(),
                        lastOnline: serverTimestamp()
                    });

                    console.log('âœ… User data loaded:', userName);
                } else {
                    console.log('âš ï¸ User document not found, creating...');
                    await setDoc(userRef, {
                        uid: currentUser.uid,
                        name: currentUser.email.split('@')[0],
                        email: currentUser.email,
                        avatarColor: getRandomColor(),
                        online: true,
                        lastSeen: serverTimestamp(),
                        lastOnline: serverTimestamp(),
                        createdAt: serverTimestamp(),
                        peerId: ''
                    });
                }
            } catch (error) {
                console.error('âŒ Error loading user data:', error);
            }
        }

        // ====== CHAT FUNCTIONS ======
        function loadChats() {
            if (chatsUnsubscribe) chatsUnsubscribe();

            const chatsQuery = query(
                collection(db, "chats"),
                where("participants", "array-contains", currentUser.uid)
            );

            chatsUnsubscribe = onSnapshot(chatsQuery, async (snapshot) => {
                if (searchInput.value.trim() !== '') {
                    return;
                }

                if (snapshot.empty) {
                    chatList.innerHTML = `
                        <div class="empty-chat">
                            <div class="empty-chat-icon">
                                <i class="fas fa-comments"></i>
                            </div>
                            <h3>No chats yet</h3>
                            <p>Search for users to start new conversations.</p>
                        </div>
                    `;
                    return;
                }

                chatList.innerHTML = '';

                const userChats = new Map();

                snapshot.forEach((docSnapshot) => {
                    const chat = docSnapshot.data();
                    chat.id = docSnapshot.id;

                    // Skip chats that are hidden for current user
                    if (chat.hiddenFor && chat.hiddenFor.includes(currentUser.uid)) {
                        return;
                    }

                    if (chat.isGroup) {
                        userChats.set(chat.id, chat);
                    } else {
                        const otherUserId = chat.participants.find(id => id !== currentUser.uid);
                        if (!otherUserId) return;

                        const existingChat = userChats.get(otherUserId);

                        if (!existingChat) {
                            userChats.set(otherUserId, chat);
                        } else {
                            const existingTime = existingChat.lastMessageTime?.seconds || 0;
                            const newTime = chat.lastMessageTime?.seconds || 0;

                            if (newTime > existingTime) {
                                userChats.set(otherUserId, chat);
                                deleteDoc(doc(db, "chats", existingChat.id)).catch(console.error);
                            } else {
                                deleteDoc(docSnapshot.ref).catch(console.error);
                            }
                        }
                    }
                });

                const chats = Array.from(userChats.values());
                chats.sort((a, b) => {
                    const timeA = a.lastMessageTime?.seconds || 0;
                    const timeB = b.lastMessageTime?.seconds || 0;
                    return timeB - timeA;
                });

                for (const chat of chats) {
                    await renderChatItem(chat, chat.id);
                }
            });
        }

        async function renderChatItem(chat, chatId) {
            try {
                if (chat.isGroup) {
                    await renderGroupChatItem(chat, chatId);
                } else {
                    await renderIndividualChatItem(chat, chatId);
                }
            } catch (error) {
                console.error('Error rendering chat item:', error);
            }
        }

        async function renderIndividualChatItem(chat, chatId) {
            const otherUserId = chat.participants.find(id => id !== currentUser.uid);
            if (!otherUserId) return;

            const otherUserDoc = await getDoc(doc(db, "users", otherUserId));

            if (!otherUserDoc.exists()) {
                return;
            }

            const otherUser = otherUserDoc.data();
            const lastMessage = chat.lastMessage || 'No messages yet';
            const decryptedLastMessage = lastMessage !== 'No messages yet' ? CryptoJS.AES.decrypt(lastMessage, "secretKey").toString(CryptoJS.enc.Utf8) : lastMessage;
            const lastMessageTime = chat.lastMessageTime ? formatTime(chat.lastMessageTime.toDate()) : '';

            let unreadCount = 0;
            if (chat.unreadCount && chat.unreadCount[currentUser.uid]) {
                unreadCount = chat.unreadCount[currentUser.uid];
            }

            let profilePicture = chat.profilePictures?.[otherUserId] || otherUser.profilePicture;

            const chatItem = document.createElement('div');
            chatItem.className = 'chat-item';
            chatItem.dataset.chatId = chatId;
            chatItem.dataset.userId = otherUserId;
            chatItem.onclick = () => openChat(chatId, otherUser);

            let statusIcon = '';
            if (chat.sender === currentUser.uid) {
                if (chat.readBy?.includes(otherUserId)) {
                    statusIcon = '<i class="fas fa-check-double blue-tick"></i>';
                } else {
                    statusIcon = '<i class="fas fa-check-double"></i>';
                }
            }

            const avatarStyle = profilePicture
                ? `background-image: url(${profilePicture}); background-size: cover; background-position: center;`
                : `background-color: ${otherUser.avatarColor || '#25D366'}`;

            const avatarContent = profilePicture ? '' : otherUser.name.charAt(0).toUpperCase();

            chatItem.innerHTML = `
                <div class="avatar-container ${otherUser.online ? 'avatar-online' : ''}">
                    <div class="chat-avatar" style="${avatarStyle}">
                        ${avatarContent}
                    </div>
                </div>
                <div class="chat-info">
                    <div class="chat-header">
                        <div class="chat-name">${otherUser.name}</div>
                        <div class="chat-time">${lastMessageTime}</div>
                    </div>
                    <div class="chat-preview">
                        <div class="chat-message">${decryptedLastMessage}</div>
                        ${statusIcon}
                        ${unreadCount > 0 ? `<div class="unread-badge">${unreadCount}</div>` : ''}
                    </div>
                </div>
                <div class="chat-actions-menu">
                    <div class="chat-action-btn delete" onclick="showDeleteChatModal('${chatId}', event)">
                        <i class="fas fa-trash-alt"></i>
                    </div>
                </div>
            `;

            chatList.appendChild(chatItem);
        }

        async function renderGroupChatItem(chat, chatId) {
            const lastMessage = chat.lastMessage || 'No messages yet';
            const decryptedLastMessage = lastMessage !== 'No messages yet' ? CryptoJS.AES.decrypt(lastMessage, "secretKey").toString(CryptoJS.enc.Utf8) : lastMessage;
            const lastMessageTime = chat.lastMessageTime ? formatTime(chat.lastMessageTime.toDate()) : '';

            let unreadCount = 0;
            if (chat.unreadCount && chat.unreadCount[currentUser.uid]) {
                unreadCount = chat.unreadCount[currentUser.uid];
            }

            const chatItem = document.createElement('div');
            chatItem.className = 'chat-item';
            chatItem.dataset.chatId = chatId;
            chatItem.dataset.isGroup = 'true';
            chatItem.onclick = (e) => {
                // Prevent opening if clicking delete
                if (e.target.closest('.chat-action-btn')) return;
                openGroupChat(chatId, chat);
            };

            const avatarStyle = chat.groupAvatar
                ? `background-image: url(${chat.groupAvatar}); background-size: cover; background-position: center;`
                : `background-color: ${chat.avatarColor || '#25D366'}`;

            const avatarContent = chat.groupAvatar ? '' : `<i class="fas fa-users"></i>`;

            chatItem.innerHTML = `
                <div class="avatar-container">
                    <div class="chat-avatar" style="${avatarStyle}">
                        ${avatarContent}
                    </div>
                </div>
                <div class="chat-info">
                    <div class="chat-header">
                        <div class="chat-name">${chat.groupName} <span class="group-chat-indicator">ðŸ‘¥</span></div>
                        <div class="chat-time">${lastMessageTime}</div>
                    </div>
                    <div class="chat-preview">
                        <div class="chat-message">${decryptedLastMessage}</div>
                        ${unreadCount > 0 ? `<div class="unread-badge">${unreadCount}</div>` : ''}
                    </div>
                </div>
                <div class="chat-actions-menu">
                    <div class="chat-action-btn delete" onclick="showDeleteChatModal('${chatId}', event)">
                        <i class="fas fa-trash-alt"></i>
                    </div>
                </div>
            `;

            chatList.appendChild(chatItem);
        }

        async function openChat(chatId, contact) {
            if (clickDebounce) return;
            clickDebounce = true;
            setTimeout(() => clickDebounce = false, 300);

            console.log('Opening chat:', chatId, 'with:', contact.name);
            currentChatId = chatId;
            currentContact = contact;
            currentGroupId = null;
            currentGroupMembers = [];

            contactName.textContent = contact.name;

            const profilePicture = await loadProfilePicture(contact.uid);
            if (profilePicture) {
                contactAvatar.style.backgroundImage = `url(${profilePicture})`;
                contactAvatar.textContent = '';
            } else {
                contactAvatar.style.backgroundImage = '';
                contactAvatar.textContent = contact.name.charAt(0).toUpperCase();
                contactAvatar.style.backgroundColor = contact.avatarColor || '#25D366';
            }

            if (contact.online) {
                contactStatus.textContent = 'Online';
                onlineDot.style.display = 'block';
            } else if (contact.lastSeen) {
                contactStatus.textContent = `Last seen ${formatTime(contact.lastSeen.toDate())}`;
                onlineDot.style.display = 'none';
            } else {
                contactStatus.textContent = 'Offline';
                onlineDot.style.display = 'none';
            }

            document.querySelectorAll('.chat-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelectorAll('.search-result-item').forEach(item => {
                item.classList.remove('active');
            });

            const activeChat = document.querySelector(`[data-chat-id="${chatId}"]`);
            if (activeChat) activeChat.classList.add('active');

            await resetUnreadCount(chatId);

            if (window.innerWidth <= 768) {
                sidebar.classList.add('hidden');
                chatArea.classList.add('active');
                document.querySelector('.back-to-chats').style.display = 'flex';

                swipeHint.style.display = 'flex';
                setTimeout(() => {
                    swipeHint.style.display = 'none';
                }, 3000);
            }

            messageInput.disabled = false;
            messageInput.placeholder = "Type a message";
            messageInput.focus();

            // Mark messages as read immediately when opening chat
            markMessagesAsRead();
            loadMessages();

            sendButton.style.display = 'flex';
            micButton.style.display = 'none';
            stopVoiceButton.style.display = 'none';

            setupMessageContextMenu();
        }

        async function openGroupChat(chatId, groupData) {
            if (clickDebounce) return;
            clickDebounce = true;
            setTimeout(() => clickDebounce = false, 300);

            console.log('Opening group chat:', chatId, 'with:', groupData.groupName);
            currentChatId = chatId;
            currentGroupId = chatId;
            currentContact = null;
            currentGroupMembers = groupData.participants || [];

            contactName.textContent = `${groupData.groupName} ðŸ‘¥`;

            if (groupData.groupAvatar) {
                contactAvatar.style.backgroundImage = `url(${groupData.groupAvatar})`;
                contactAvatar.textContent = '';
            } else {
                contactAvatar.style.backgroundImage = '';
                contactAvatar.textContent = '<i class="fas fa-users"></i>';
                contactAvatar.style.backgroundColor = groupData.avatarColor || '#25D366';
                contactAvatar.innerHTML = '<i class="fas fa-users"></i>';
            }

            const memberCount = groupData.participants?.length || 0;
            contactStatus.textContent = `${memberCount} member${memberCount !== 1 ? 's' : ''}`;
            onlineDot.style.display = 'none';

            document.querySelectorAll('.chat-item').forEach(item => {
                item.classList.remove('active');
            });

            const activeChat = document.querySelector(`[data-chat-id="${chatId}"]`);
            if (activeChat) activeChat.classList.add('active');

            await resetUnreadCount(chatId);

            if (window.innerWidth <= 768) {
                sidebar.classList.add('hidden');
                chatArea.classList.add('active');
                document.querySelector('.back-to-chats').style.display = 'flex';

                swipeHint.style.display = 'flex';
                setTimeout(() => {
                    swipeHint.style.display = 'none';
                }, 3000);
            }

            messageInput.disabled = false;
            messageInput.placeholder = "Type a message to the group";
            messageInput.focus();

            loadMessages();

            sendButton.style.display = 'flex';
            micButton.style.display = 'none';
            stopVoiceButton.style.display = 'none';

            setupMessageContextMenu();
        }

        window.showChatList = () => {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('hidden');
                chatArea.classList.remove('active');
                searchInput.value = '';
                loadChats();
                hideTypingIndicator();
            }
        };

        // ====== MESSAGE FUNCTIONS ======
        function loadMessages() {
            if (messageUnsubscribe) {
                messageUnsubscribe();
            }

            if (!currentChatId) {
                messagesContainer.innerHTML = `
                    <div class="empty-chat">
                        <div class="empty-chat-icon">
                            <i class="fas fa-comment-slash"></i>
                        </div>
                        <h3>No chat selected</h3>
                        <p>Select a chat from the list or search for a user to start messaging.</p>
                    </div>
                `;
                return;
            }

            console.log('Loading messages for chat:', currentChatId);

            try {
                const messagesQuery = query(
                    collection(db, "messages"),
                    where("chatId", "==", currentChatId)
                );

                messageUnsubscribe = onSnapshot(messagesQuery, (snapshot) => {
                    console.log('Messages loaded:', snapshot.size, 'messages');

                    if (snapshot.empty) {
                        messagesContainer.innerHTML = `
                            <div class="empty-chat">
                                <div class="empty-chat-icon">
                                    <i class="fas fa-comment"></i>
                                </div>
                                <h3>No messages yet</h3>
                                <p>Send your first message to start the conversation.</p>
                            </div>
                        `;
                        return;
                    }

                    messagesContainer.innerHTML = `
                        <div class="encryption-notice">
                            <i class="fas fa-lock"></i> Messages are end-to-end encrypted. No one outside of this chat can read them.
                        </div>
                    `;
                    const messages = [];

                    snapshot.forEach((docSnapshot) => {
                        const message = docSnapshot.data();
                        messages.push({ ...message, id: docSnapshot.id });
                    });

                    messages.sort((a, b) => {
                        const timeA = a.timestamp?.seconds || 0;
                        const timeB = b.timestamp?.seconds || 0;
                        return timeA - timeB;
                    });

                    messages.forEach(message => {
                        renderMessage(message, message.id);
                    });

                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }, 100);

                    markMessagesAsRead();
                    setupMessageContextMenu();
                }, (error) => {
                    console.error('Error loading messages:', error);
                    showToast('Error loading messages', 'error');
                });
            } catch (error) {
                console.error('Error creating query:', error);
                showToast('Error loading messages', 'error');
            }
        }

        function renderMessage(message, messageId) {
            const messageRow = document.createElement('div');
            messageRow.className = `message-row ${message.sender === currentUser.uid ? 'sent' : 'received'}`;
            messageRow.dataset.messageId = messageId;

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.sender === currentUser.uid ? 'sent' : 'received'} ${message.deleted ? 'deleted-message' : ''}`;
            messageDiv.dataset.messageId = messageId;
            messageDiv.dataset.messageText = message.text || '';

            const time = message.timestamp ? formatTime(message.timestamp.toDate()) : 'Just now';
            const isSystem = message.type === 'system';
            const isDeleted = message.deleted || false;
            const isDeletedForMe = message.deletedFor?.includes(currentUser.uid);

            // Decrypt message text
            if (!isSystem && !isDeleted && !isDeletedForMe && message.text) {
                try {
                    message.text = CryptoJS.AES.decrypt(message.text, "secretKey").toString(CryptoJS.enc.Utf8);
                } catch (e) {
                    console.error('Decryption failed', e);
                }
            }
            if (message.replyTo && message.replyTo.text) {
                try {
                    message.replyTo.text = CryptoJS.AES.decrypt(message.replyTo.text, "secretKey").toString(CryptoJS.enc.Utf8);
                } catch (e) {
                    console.error('Reply decryption failed', e);
                }
            }

            let statusIcon = '';
            if (message.sender === currentUser.uid && !isSystem && !isDeleted && !isDeletedForMe) {
                // Check if message has been read
                let hasBeenRead = false;
                if (currentGroupId) {
                    // For group chats, show blue ticks when read by all participants
                    // This is simplified - in practice, you'd need to check all group members
                    hasBeenRead = message.readBy && message.readBy.length > 1;
                } else {
                    // For 1-on-1 chats, show blue ticks when read by the recipient
                    hasBeenRead = message.readBy && message.readBy.some(uid => uid !== currentUser.uid);
                }

                if (hasBeenRead) {
                    statusIcon = '<i class="fas fa-check-double blue-tick"></i>';
                } else if (message.delivered) {
                    statusIcon = '<i class="fas fa-check-double"></i>';
                } else {
                    statusIcon = '<i class="fas fa-check"></i>';
                }
            }

            let replyContent = '';
            if (message.replyTo && !isDeleted && !isDeletedForMe) {
                replyContent = `
                    <div class="replied-message-bubble" onclick="scrollToMessage('${message.replyTo.id}')">
                        <div class="replied-sender-name" id="replied-sender-${messageId}">${message.replyTo.sender === currentUser.uid ? 'You' : '...'}</div>
                        <div class="replied-text-content">${escapeHtml(message.replyTo.text)}</div>
                    </div>
                `;
                if (message.replyTo.sender !== currentUser.uid) {
                    getUserName(message.replyTo.sender).then(name => {
                        const el = document.getElementById(`replied-sender-${messageId}`);
                        if (el) el.textContent = name;
                    });
                }
            }

            let messageContent = '';
            if (isSystem) {
                messageContent = `<div class="message-content system-message">${message.text}</div>`;
                statusIcon = '';
            } else if (isDeleted || isDeletedForMe) {
                messageContent = `<div class="message-content"><i>This message was deleted</i></div>`;
                statusIcon = '<i class="fas fa-ban" style="color: #8696a0;"></i>';
            } else if (message.type === 'image') {
                messageContent = `
                    <div class="message-content image-preview-container">
                        <img src="${message.content}" class="image-preview" 
                             onclick="openImage('${escapeHtml(message.content).replace(/'/g, "\\'")}')" 
                             alt="${escapeHtml(message.fileName || 'Image')}" />
                        <div class="image-overlay">
                            <button class="image-download-btn" onclick="downloadImage('${escapeHtml(message.content).replace(/'/g, "\\'")}', '${escapeHtml(message.fileName || 'image')}')">
                                <i class="fas fa-download"></i>
                            </button>
                        </div>
                    </div>
                `;
            } else if (message.type === 'video') {
                messageContent = `
                    <div class="message-content">
                        ${currentGroupId && message.sender !== currentUser.uid ? `<div class="group-sender-name" style="color: ${message.senderColor || '#53bdeb'}; font-size: 12px; font-weight: bold; margin-bottom: 2px;">${escapeHtml(message.senderName || 'Unknown')}</div>` : ''}
                        <video controls class="image-preview">
                            <source src="${message.content}" type="${message.fileType || 'video/mp4'}">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                `;
            } else if (message.type === 'voice') {
                messageContent = `
                    <div class="message-content voice-message-container">
                        ${currentGroupId && message.sender !== currentUser.uid ? `<div class="group-sender-name" style="color: ${message.senderColor || '#53bdeb'}; font-size: 12px; font-weight: bold; margin-bottom: 2px;">${escapeHtml(message.senderName || 'Unknown')}</div>` : ''}
                        <i class="fas fa-play" style="cursor: pointer;" onclick="playVoiceMessage('${escapeHtml(message.content).replace(/'/g, "\\'")}')"></i>
                        <div class="voice-wave">
                            <div class="voice-bar"></div>
                            <div class="voice-bar"></div>
                            <div class="voice-bar"></div>
                            <div class="voice-bar"></div>
                            <div class="voice-bar"></div>
                        </div>
                        <div class="voice-duration">${message.duration || '0:00'}</div>
                    </div>
                `;
            } else if (message.type === 'document') {
                messageContent = `
                    <div class="message-content file-message">
                        ${currentGroupId && message.sender !== currentUser.uid ? `<div class="group-sender-name" style="color: ${message.senderColor || '#53bdeb'}; font-size: 12px; font-weight: bold; margin-bottom: 2px;">${escapeHtml(message.senderName || 'Unknown')}</div>` : ''}
                        <div class="file-icon">
                            <i class="fas fa-file"></i>
                        </div>
                        <div class="file-info">
                            <div class="file-name">${escapeHtml(message.fileName || 'File')}</div>
                            <div class="file-size">${formatFileSize(message.fileSize)}</div>
                            ${message.fileSize > 5 * 1024 * 1024 ?
                        '<div class="file-size-warning"><i class="fas fa-info-circle"></i> Large file - download may be slow</div>' : ''}
                        </div>
                        <button class="download-btn" onclick="downloadFile('${escapeHtml(message.content).replace(/'/g, "\\'")}', '${escapeHtml(message.fileName || 'file')}', '${escapeHtml(message.fileType || '')}')">
                            <i class="fas fa-download"></i>
                        </button>
                    </div>
                `;
            } else if (message.type === 'location') {
                messageContent = `
                    <div class="message-content location-message">
                        ${currentGroupId && message.sender !== currentUser.uid ? `<div class="group-sender-name" style="color: ${message.senderColor || '#53bdeb'}; font-size: 12px; font-weight: bold; margin-bottom: 2px;">${escapeHtml(message.senderName || 'Unknown')}</div>` : ''}
                        <div class="location-preview">
                            <div class="location-icon">
                                <i class="fas fa-map-marker-alt"></i>
                            </div>
                        </div>
                        <div class="location-info">
                            <div class="location-address">${escapeHtml(message.address)}</div>
                            <div class="location-coordinates">
                                ${message.latitude.toFixed(6)}, ${message.longitude.toFixed(6)}
                            </div>
                            <div class="location-actions">
                                <button class="location-btn" onclick="window.open('https://www.google.com/maps?q=${message.latitude},${message.longitude}', '_blank')">
                                    <i class="fab fa-google"></i> Google Maps
                                </button>
                                <button class="location-btn" onclick="window.open('https://www.openstreetmap.org/?mlat=${message.latitude}&mlon=${message.longitude}', '_blank')">
                                    <i class="fas fa-map"></i> OpenStreetMap
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            } else if (message.type === 'large-file') {
                const isCached = window.receivedFileCache && window.receivedFileCache.has(message.transferId);
                messageContent = `
                    <div class="message-content file-message">
                         ${currentGroupId && message.sender !== currentUser.uid ? `<div class="group-sender-name" style="color: ${message.senderColor || '#53bdeb'}; font-size: 12px; font-weight: bold; margin-bottom: 2px;">${escapeHtml(message.senderName || 'Unknown')}</div>` : ''}
                        <div class="file-icon">
                            <i class="fas fa-file-archive"></i>
                        </div>
                        <div class="file-info">
                            <div class="file-name">${escapeHtml(message.fileName || 'Large File')}</div>
                            <div class="file-size">${formatFileSize(message.fileSize)}</div>
                            <div class="file-size-warning">
                                <i class="fas fa-puzzle-piece"></i> Large file sent via WebRTC
                            </div>
                        </div>
                        <div class="file-actions" style="display: flex; gap: 8px;">
                            <button class="download-btn" onclick="downloadLargeFile('${message.chatId}', '${message.transferId}', '${escapeHtml(message.fileName)}', ${message.fileSize}, '${escapeHtml(message.content || '')}')">
                                <i class="fas fa-download"></i>
                            </button>
                            ${isCached || message.sender === currentUser.uid ? `
                            <button class="view-btn" onclick="viewLargeFile('${message.transferId}', '${escapeHtml(message.fileName)}', '${escapeHtml(message.fileType || '')}')" title="View">
                                <i class="fas fa-eye"></i>
                            </button>` : ''}
                        </div>
                    </div>
                `;
            } else {
                messageContent = `<div class="message-content">${currentGroupId && message.sender !== currentUser.uid ? `<div class="group-sender-name" style="color: ${message.senderColor || '#53bdeb'}; font-size: 12px; font-weight: bold; margin-bottom: 2px;">${escapeHtml(message.senderName || 'Unknown')}</div>` : ''}${processMessageText(message.text)}</div>`;
            }

            messageDiv.innerHTML = `
                ${replyContent}
                ${messageContent}
                <div class="message-time">
                    ${time}
                    ${statusIcon}
                </div>
            `;

            // Long press handler for ALL messages
            messageDiv.oncontextmenu = (e) => {
                e.preventDefault();
                showMessageContextMenu(e, messageDiv);
            };
            messageDiv.addEventListener('touchstart', (e) => {
                window.lastTouchX = e.touches[0].clientX;
                window.lastTouchY = e.touches[0].clientY;
                handleMessageLongPress(e, messageDiv);
            });
            messageDiv.addEventListener('touchmove', (e) => {
                // If user moves finger more than 10px, it's a scroll, cancel long press
                if (Math.abs(e.touches[0].clientX - window.lastTouchX) > 10 ||
                    Math.abs(e.touches[0].clientY - window.lastTouchY) > 10) {
                    clearMessageLongPress();
                }
            });
            messageDiv.addEventListener('touchend', clearMessageLongPress);
            messageDiv.addEventListener('mousedown', (e) => {
                handleMessageLongPress(e, messageDiv);
            });
            messageDiv.addEventListener('mouseup', clearMessageLongPress);

            if (currentGroupId && message.sender !== currentUser.uid && !message.senderName) {
                getUserName(message.sender).then(name => {
                    const nameEl = messageDiv.querySelector('.group-sender-name');
                    if (nameEl) nameEl.textContent = name;
                });
            }

            // Ensure ID is attached for context menu
            if (message.id) messageDiv.dataset.id = message.id;
            messageDiv.dataset.text = message.text || '';
            messageDiv.dataset.type = message.type || 'text';
            messageDiv.dataset.sender = message.sender || '';
            messageDiv.dataset.content = message.content || '';
            messageDiv.dataset.fileName = message.fileName || '';
            messageDiv.dataset.fileSize = message.fileSize || '';
            messageDiv.dataset.fileType = message.fileType || '';
            messageDiv.dataset.address = message.address || '';
            messageDiv.dataset.latitude = message.latitude || '';
            messageDiv.dataset.longitude = message.longitude || '';
            messageDiv.dataset.duration = message.duration || '';
            messageDiv.dataset.transferId = message.transferId || '';

            messageRow.appendChild(messageDiv);
            messagesContainer.appendChild(messageRow);
        }

        window.sendMessage = async () => {
            const text = messageInput.value.trim();
            if (!text && !isRecording) {
                return;
            }

            const encryptedText = CryptoJS.AES.encrypt(text, "secretKey").toString();

            if (!currentChatId) {
                showToast('Please select a chat first', 'error');
                return;
            }

            console.log('Sending message to chat:', currentChatId);

            try {
                const messageData = {
                    chatId: currentChatId,
                    sender: currentUser.uid,
                    text: encryptedText,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid],
                    delivered: false,
                    deleted: false,
                    deletedFor: [],
                    reactions: {},
                    userReactions: {},
                    replyTo: replyingTo || null
                };

                const messageRef = await addDoc(collection(db, "messages"), messageData);

                if (currentGroupId) {
                    await updateDoc(doc(db, "chats", currentChatId), {
                        lastMessage: encryptedText,
                        lastMessageTime: serverTimestamp(),
                        sender: currentUser.uid,
                        readBy: [currentUser.uid]
                    });
                } else {
                    await updateDoc(doc(db, "chats", currentChatId), {
                        lastMessage: encryptedText,
                        lastMessageTime: serverTimestamp(),
                        sender: currentUser.uid,
                        readBy: [currentUser.uid],
                        [`unreadCount.${currentContact.uid}`]: increment(1)
                    });
                }

                messageInput.value = '';

                await updateTypingStatus(false);

                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);

                setTimeout(async () => {
                    try {
                        await updateDoc(doc(db, "messages", messageRef.id), {
                            delivered: true
                        });
                    } catch (error) {
                        console.error('Error marking as delivered:', error);
                    }
                }, 1000);

                playMessageSound('send');

            } catch (error) {
                console.error('Error sending message:', error);
                showToast('Failed to send message. Please try again.', 'error');
            }
        };

        async function handleImagePaste(file) {
            if (!file || !file.type.startsWith('image/')) return;

            try {
                await sendFileAsBase64(file, 'image');
                showToast('Image pasted and sent!');
            } catch (error) {
                console.error('Error handling image paste:', error);
                showToast('Failed to paste image', 'error');
            }
        }

        window.handleKeyPress = (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        };

        window.handleTyping = () => {
            if (!currentChatId) return;

            if (isTypingTimeout) {
                clearTimeout(isTypingTimeout);
            }

            updateTypingStatus(true);

            isTypingTimeout = setTimeout(() => {
                updateTypingStatus(false);
            }, 2000);
        };

        async function updateTypingStatus(isTyping) {
            if (!currentChatId || !currentUser) return;

            try {
                await updateDoc(doc(db, "chats", currentChatId), {
                    [`typing.${currentUser.uid}`]: isTyping,
                    lastActivity: serverTimestamp()
                });
            } catch (error) {
                console.error('Error updating typing status:', error);
            }
        }

        // ====== IMAGE DOWNLOAD FUNCTIONS ======
        let imageLongPressTimer = null;

        window.handleImageLongPress = (e, imageUrl, fileName) => {
            e.preventDefault();
            imageLongPressTimer = setTimeout(() => {
                downloadImage(imageUrl, fileName);
            }, 1000);
        };

        window.clearImageLongPress = () => {
            if (imageLongPressTimer) {
                clearTimeout(imageLongPressTimer);
                imageLongPressTimer = null;
            }
        };

        window.downloadImage = async (imageUrl, fileName) => {
            try {
                if (imageUrl.startsWith('data:image')) {
                    const link = document.createElement('a');
                    link.href = imageUrl;
                    link.download = fileName || 'image.jpg';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else {
                    const response = await fetch(imageUrl);
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName || 'image.jpg';
                    document.body.appendChild(link);
                    link.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(link);
                }
                showToast('Image download started');
            } catch (error) {
                console.error('Error downloading image:', error);
                showToast('Failed to download image', 'error');
            }
        };

        // ====== MESSAGE CONTEXT MENU ======
        // Removed setupMessageContextMenu, showMessageContextMenu, hideMessageContextMenu, copyMessageText, copyMessageTextFromClick, replyToMessage, forwardMessage, getMessageType, showForwardModal, closeForwardModal, loadForwardContacts, renderForwardContact, selectForwardContact, confirmForwardMessage, deleteMessageFromContext
        // Replaced with new context menu logic below

        // ====== SEARCH FUNCTIONS ======
        window.searchUsers = debounce(async () => {
            const searchTerm = searchInput.value.trim();

            if (!searchTerm) {
                loadChats();
                return;
            }

            chatList.innerHTML = '<div class="spinner"></div>';

            try {
                const usersQuery = query(collection(db, "users"));
                const snapshot = await getDocs(usersQuery);

                if (snapshot.empty) {
                    chatList.innerHTML = `
                        <div class="no-results">
                            <p>No users found</p>
                        </div>
                    `;
                    return;
                }

                chatList.innerHTML = '';
                let foundUsers = false;

                snapshot.forEach((userDoc) => {
                    const user = userDoc.data();

                    if (user.uid === currentUser.uid) return;

                    const matchesSearch = user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        user.email.toLowerCase().includes(searchTerm.toLowerCase());

                    if (matchesSearch) {
                        foundUsers = true;
                        renderSearchResult(user);
                    }
                });

                if (!foundUsers) {
                    chatList.innerHTML = `
                        <div class="no-results">
                            <p>No users found for "${searchTerm}"</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Search error:', error);
                chatList.innerHTML = `
                    <div class="no-results">
                        <p>Error searching users. Please try again.</p>
                    </div>
                `;
            }
        }, 300);

        async function renderSearchResult(user) {
            const participants = [currentUser.uid, user.uid].sort();
            const chatId = participants.join('_');

            let existingChatId = null;
            try {
                const chatDoc = await getDoc(doc(db, "chats", chatId));
                if (chatDoc.exists()) {
                    existingChatId = chatId;
                }
            } catch (error) {
                console.error('Error checking chat:', error);
            }

            const profilePicture = user.profilePicture;
            const avatarStyle = profilePicture
                ? `background-image: url(${profilePicture}); background-size: cover; background-position: center;`
                : `background-color: ${user.avatarColor || '#25D366'}`;

            const avatarContent = profilePicture ? '' : user.name.charAt(0).toUpperCase();

            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            resultItem.dataset.userId = user.uid;
            resultItem.onclick = async () => {
                await handleSearchResultClick(user, existingChatId, chatId);
            };

            resultItem.innerHTML = `
                <div class="chat-avatar" style="${avatarStyle}">
                    ${avatarContent}
                </div>
                <div class="search-result-info">
                    <div class="search-result-name">${user.name}</div>
                    <div class="search-result-email">${user.email}</div>
                    <div style="font-size: 12px; color: #8696a0; margin-top: 4px;">
                        ${existingChatId ? 'Click to open existing chat' : 'Click to start new chat'}
                    </div>
                </div>
            `;

            chatList.appendChild(resultItem);
        }

        async function handleSearchResultClick(user, existingChatId, chatId) {
            searchInput.value = '';

            if (existingChatId) {
                openChat(existingChatId, user);
            } else {
                await createNewChat(user, chatId);
            }
        }

        async function createNewChat(contact, chatId) {
            try {
                console.log('Creating new chat with ID:', chatId);

                const profilePicture = await loadProfilePicture(contact.uid);
                const profilePictures = {
                    [currentUser.uid]: userProfilePicture,
                    [contact.uid]: profilePicture
                };

                await setDoc(doc(db, "chats", chatId), {
                    id: chatId,
                    participants: [currentUser.uid, contact.uid],
                    lastMessage: '',
                    lastMessageTime: serverTimestamp(),
                    createdBy: currentUser.uid,
                    createdAt: serverTimestamp(),
                    readBy: [currentUser.uid],
                    typing: {},
                    unreadCount: {
                        [currentUser.uid]: 0,
                        [contact.uid]: 0
                    },
                    profilePictures: profilePictures
                });

                await addDoc(collection(db, "messages"), {
                    chatId: chatId,
                    sender: "system",
                    text: `You started a chat with ${contact.name}`,
                    timestamp: serverTimestamp(),
                    type: "system"
                });

                openChat(chatId, contact);
                loadChats();

            } catch (error) {
                console.error('Error creating chat:', error);
                showToast('Failed to create chat. Please try again.', 'error');
            }
        }
        // ====== FILE UPLOAD FUNCTIONS ======
        window.attachImage = () => {
            attachmentMenu.classList.remove('active');
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,video/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const fileKey = `${file.name}_${file.size}_${Date.now()}`;
                    if (sessionStorage.getItem(`uploaded_${fileKey}`)) {
                        showToast('This file was already sent recently', 'warning');
                        return;
                    }

                    if (file.size > 5 * 1024 * 1024) {
                        showToast('File too large (max 5MB for direct upload). Using WebRTC for transfer.', 'warning');
                        await sendLargeFileViaDataChannel(file, file.type.startsWith('image') ? 'image' : 'video');
                    } else {
                        await sendFileAsBase64(file, file.type.startsWith('image') ? 'image' : 'video');
                        sessionStorage.setItem(`uploaded_${fileKey}`, 'true');
                        setTimeout(() => {
                            sessionStorage.removeItem(`uploaded_${fileKey}`);
                        }, 5 * 60 * 1000);
                    }
                }
            };
            input.click();
        };

        window.attachDocument = () => {
            attachmentMenu.classList.remove('active');
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '*/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const fileKey = `${file.name}_${file.size}_${Date.now()}`;
                    if (sessionStorage.getItem(`uploaded_${fileKey}`)) {
                        showToast('This file was already sent recently', 'warning');
                        return;
                    }

                    if (file.size > 5 * 1024 * 1024) {
                        showToast('File too large (max 5MB for direct upload). Using WebRTC for transfer.', 'warning');
                        await sendLargeFileViaDataChannel(file, 'document');
                    } else {
                        await sendFileAsBase64(file, 'document');
                        sessionStorage.setItem(`uploaded_${fileKey}`, 'true');
                        setTimeout(() => {
                            sessionStorage.removeItem(`uploaded_${fileKey}`);
                        }, 5 * 60 * 1000);
                    }
                }
            };
            input.click();
        };

        async function transferFile(conn, file, transferId, chatId) {
            console.log(`Starting transfer for ${file.name} to ${conn.peer}`);

            try {
                conn.send(JSON.stringify({
                    type: 'file-metadata',
                    transferId: transferId,
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type,
                    chatId: chatId,
                    senderId: currentUser.uid,
                    totalChunks: Math.ceil(file.size / (16 * 1024))
                }));

                const CHUNK_SIZE = 16 * 1024;
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

                const arrayBuffer = await file.arrayBuffer();

                for (let i = 0; i < totalChunks; i++) {
                    if (!conn.open) throw new Error('Connection closed');

                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = arrayBuffer.slice(start, end);

                    conn.send(chunk);

                    // Update UI if this is the active manual upload
                    const modal = document.getElementById('largeFileUploadModal');
                    const nameEl = document.getElementById('largeFileName');
                    if (modal && modal.style.display === 'block' && nameEl && nameEl.textContent === file.name) {
                        const progress = Math.round(((i + 1) / totalChunks) * 100);
                        updateLargeFileProgress(progress, i + 1, totalChunks);
                    }

                    // Small delay to prevent buffer overflow
                    if (i % 10 === 0) await new Promise(resolve => setTimeout(resolve, 10));
                }

                if (conn.open) {
                    conn.send(JSON.stringify({
                        type: 'file-complete',
                        transferId: transferId
                    }));
                }

                console.log('File transfer complete');
                return true;
            } catch (error) {
                console.error('Transfer failed:', error);
                return false;
            }
        }

        async function finalizeFileUpload(file, fileType, transferId, chatId) {
            const messageData = {
                chatId: chatId,
                sender: currentUser.uid,
                type: 'large-file',
                transferId: transferId,
                fileName: file.name,
                fileSize: file.size,
                fileType: file.type,
                timestamp: serverTimestamp(),
                readBy: [currentUser.uid],
                delivered: false
            };

            await addDoc(collection(db, "messages"), messageData);

            await updateDoc(doc(db, "chats", currentChatId), {
                lastMessage: `ðŸ“ ${file.name}`,
                lastMessageTime: serverTimestamp(),
                sender: currentUser.uid,
                [`unreadCount.${currentContact?.uid || 'group'}`]: increment(1)
            });
        }

        async function sendLargeFileViaDataChannel(file, fileType) {
            if (!currentChatId) {
                showToast('Please select a chat first', 'error');
                return;
            }

            if (largeFileUpload && largeFileUpload.file.name === file.name) {
                showToast('File is already being uploaded', 'warning');
                return;
            }

            showLargeFileUploadModal(file, fileType);

            try {
                const transferId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                // Store file for future requests
                activeFileTransfers.set(transferId, file);

                let contactPeerId = null;
                if (!currentGroupId && currentContact) {
                    contactPeerId = await getContactPeerId(currentContact.uid);
                }

                // If group or no contact peer, we notifications only
                if (currentGroupId || !contactPeerId) {
                    await finalizeFileUpload(file, fileType, transferId, currentChatId);
                    hideLargeFileUploadModal();
                    if (!currentGroupId) showToast('File notification sent. User can download when online.', 'info');
                    else showToast('Group file shared. Members can click to download.', 'info');
                    return;
                }

                const conn = peer.connect(contactPeerId, {
                    metadata: { type: 'file-push', transferId: transferId }
                });

                pendingFileTransfers.set(transferId, {
                    conn: conn,
                    startTime: Date.now()
                });

                conn.on('open', async () => {
                    console.log('Connected to peer, pushing file...');
                    await transferFile(conn, file, transferId, currentChatId);

                    pendingFileTransfers.delete(transferId);
                    setTimeout(() => conn.close(), 1000);

                    hideLargeFileUploadModal();
                    showToast('File sent successfully via WebRTC!');
                });

                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    pendingFileTransfers.delete(transferId);
                    hideLargeFileUploadModal();
                    // Don't toast error here, we still posted the notification
                    // showToast('File delivery via P2P failed, saved as requestable.', 'warning');
                });

                await finalizeFileUpload(file, fileType, transferId, currentChatId);

            } catch (error) {
                console.error('Error sending large file:', error);
                hideLargeFileUploadModal();
                showToast('Error preparing file', 'error');
            }
        }

        async function sendFileAsBase64(file, fileType) {
            if (!currentChatId) {
                showToast('Please select a chat first', 'error');
                return;
            }

            const MAX_FILE_SIZE = 5 * 1024 * 1024;
            if (file.size > MAX_FILE_SIZE) {
                showToast('File size too large (max 5MB for direct upload)', 'error');
                return;
            }

            showUploadProgress(file.name, file.size);

            try {
                const base64Data = await fileToBase64(file);

                if (base64Data.length > 1000000) {
                    showToast('File too large after conversion. Using WebRTC transfer.', 'warning');
                    hideUploadProgress();
                    await sendLargeFileViaDataChannel(file, fileType);
                    return;
                }

                updateUploadProgress(50, file.name);

                const messageData = {
                    chatId: currentChatId,
                    sender: currentUser.uid,
                    type: fileType,
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type,
                    content: base64Data,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid],
                    delivered: false
                };

                updateUploadProgress(75, file.name);

                await addDoc(collection(db, "messages"), messageData);

                updateUploadProgress(100, file.name);

                const fileMessage = fileType === 'image' ? 'ðŸ“· Photo' :
                    fileType === 'video' ? 'ðŸŽ¬ Video' : 'ðŸ“„ Document';

                const updateData = {
                    lastMessage: fileMessage,
                    lastMessageTime: serverTimestamp(),
                    sender: currentUser.uid
                };

                if (currentGroupId) {
                    updateData.readBy = [currentUser.uid];
                } else if (currentContact) {
                    updateData[`unreadCount.${currentContact.uid}`] = increment(1);
                }

                await updateDoc(doc(db, "chats", currentChatId), updateData);

                setTimeout(() => {
                    hideUploadProgress();
                }, 1000);

                showToast(`${fileType === 'image' ? 'Image' : fileType === 'video' ? 'Video' : 'File'} sent successfully!`);

            } catch (error) {
                console.error('Error sending file:', error);
                hideUploadProgress();
                showToast('Failed to send file. Please try again.', 'error');
            }
        }

        window.downloadLargeFile = async (chatId, transferId, fileName, fileSize, base64Data = null) => {
            if (base64Data && base64Data.startsWith('data:')) {
                await downloadFile(base64Data, fileName, 'application/octet-stream');
                return;
            }

            if (!window.receivedFileCache) window.receivedFileCache = new Map();

            // 1. Check Cache
            if (window.receivedFileCache.has(transferId)) {
                const blob = window.receivedFileCache.get(transferId);
                await saveFileToDevice(blob, fileName);
                return;
            }

            // 2. Check if I am the sender
            if (activeFileTransfers.has(transferId)) {
                showToast('You sent this file.', 'info');
                return;
            }

            showLargeFileDownloadModal(fileName, fileSize);

            try {
                // Find sender ID from the message
                const msgsQuery = query(collection(db, "messages"), where("transferId", "==", transferId), limit(1));
                const snapshot = await getDocs(msgsQuery);

                if (snapshot.empty) {
                    throw new Error("Message not found");
                }

                const msgData = snapshot.docs[0].data();
                const senderId = msgData.sender;

                if (senderId === currentUser.uid) {
                    hideLargeFileDownloadModal();
                    showToast('You sent this file.', 'info');
                    return;
                }

                const senderPeerId = await getContactPeerId(senderId);
                if (!senderPeerId) {
                    hideLargeFileDownloadModal();
                    showToast('Sender is offline. Cannot download file.', 'error');
                    return;
                }

                console.log(`Requesting file ${transferId} from ${senderPeerId}`);

                const conn = peer.connect(senderPeerId, {
                    metadata: { type: 'file-request' }
                });

                let receivedChunks = [];
                let fileMetadata = null;
                let totalChunks = 0;
                let receivedChunksCount = 0;

                conn.on('open', () => {
                    console.log('Connection opened, sending request...');
                    conn.send(JSON.stringify({
                        type: 'request-file',
                        transferId: transferId,
                        chatId: chatId
                    }));
                });

                conn.on('data', async (data) => {
                    try {
                        if (typeof data === 'string') {
                            const message = JSON.parse(data);

                            if (message.type === 'file-metadata') {
                                console.log('Receiving requested file metadata:', message);
                                fileMetadata = message;
                                totalChunks = message.totalChunks;
                                receivedChunks = [];
                                receivedChunksCount = 0;
                                updateDownloadProgress(0, 0, totalChunks);
                            }
                            else if (message.type === 'file-complete') {
                                console.log('File request complete');
                                const blob = new Blob(receivedChunks, { type: fileMetadata?.fileType || 'application/octet-stream' });

                                window.receivedFileCache.set(transferId, blob);

                                hideLargeFileDownloadModal();
                                await saveFileToDevice(blob, fileName);
                                showDeleteSuccessNotification('File downloaded successfully!');
                                conn.close();
                            }
                            else if (message.type === 'error') {
                                showToast(message.message, 'error');
                                hideLargeFileDownloadModal();
                                conn.close();
                            }
                        }
                        else if (data instanceof ArrayBuffer) {
                            if (fileMetadata) {
                                receivedChunks.push(data);
                                receivedChunksCount++;

                                const progress = Math.round((receivedChunksCount / totalChunks) * 100);
                                updateDownloadProgress(progress, receivedChunksCount, totalChunks);
                            }
                        }
                    } catch (err) {
                        console.error("Error processing data:", err);
                    }
                });

                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    hideLargeFileDownloadModal();
                    showToast('Connection to sender failed', 'error');
                });

            } catch (error) {
                console.error('Error downloading large file:', error);
                hideLargeFileDownloadModal();
                showToast('Failed to initiate download', 'error');
            }
        };

        function showDeleteSuccessNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'delete-success-notification';
            notification.innerHTML = `
                <i class="fas fa-check-circle"></i>
                <span>${message}</span>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function showLargeFileDownloadModal(fileName, fileSize) {
            downloadFileName.textContent = `${fileName} (${formatFileSize(fileSize)})`;
            downloadProgressFill.style.width = '0%';
            downloadProgressText.textContent = '0%';
            largeFileDownloadModal.classList.add('active');
        }

        function updateDownloadProgress(percent, currentChunk, totalChunks) {
            downloadProgressFill.style.width = `${percent}%`;
            downloadProgressText.textContent = `${percent}%`;
            downloadChunkInfo.textContent = `Chunk ${currentChunk} of ${totalChunks}`;
        }

        function hideLargeFileDownloadModal() {
            largeFileDownloadModal.classList.remove('active');
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function base64ToBlob(base64, contentType = '') {
            try {
                const byteCharacters = atob(base64.split(',')[1]);
                const byteArrays = [];

                for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                    const slice = byteCharacters.slice(offset, offset + 512);
                    const byteNumbers = new Array(slice.length);

                    for (let i = 0; i < slice.length; i++) {
                        byteNumbers[i] = slice.charCodeAt(i);
                    }

                    const byteArray = new Uint8Array(byteNumbers);
                    byteArrays.push(byteArray);
                }

                return new Blob(byteArrays, { type: contentType });
            } catch (error) {
                console.error('Error converting base64 to blob:', error);
                throw error;
            }
        }

        window.downloadFile = async (base64Data, fileName, fileType = '') => {
            try {
                const blob = base64ToBlob(base64Data, fileType);
                await saveFileToDevice(blob, fileName);
                showToast('File download started');
            } catch (error) {
                console.error('Error downloading file:', error);
                showToast('Failed to download file', 'error');
            }
        };

        window.openImage = (base64Data) => {
            const newWindow = window.open();
            newWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Image Preview</title>
                    <style>
                        body {
                            margin: 0;
                            padding: 0;
                            background: #0c1317;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            min-height: 100vh;
                        }
                        img {
                            max-width: 100%;
                            max-height: 100vh;
                            object-fit: contain;
                        }
                    </style>
                </head>
                <body>
                    <img src="${base64Data}" alt="Image Preview">
                </body>
                </html>
            `);
        };

        async function saveFileToDevice(blob, fileName) {
            try {
                if ('showSaveFilePicker' in window) {
                    try {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: fileName,
                            types: [{
                                description: 'Files',
                                accept: { '*/*': ['.*'] }
                            }]
                        });

                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();

                        return;
                    } catch (err) {
                        console.log('File System Access API not available or user cancelled:', err);
                    }
                }

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();

                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);

            } catch (error) {
                console.error('Error saving file:', error);
                throw error;
            }
        }

        // ====== WEBRTC DATACHANNEL FILE TRANSFER HANDLERS ======
        function initializeDataChannelHandlers() {
            peer.on('connection', (conn) => {
                console.log('Incoming DataChannel connection:', conn.peer);

                let receivedChunks = [];
                let fileMetadata = null;
                let totalChunks = 0;
                let receivedChunksCount = 0;

                conn.on('open', () => {
                    console.log('DataChannel connection opened');
                });

                conn.on('data', async (data) => {
                    try {
                        if (typeof data === 'string') {
                            const message = JSON.parse(data);

                            if (message.type === 'request-file') {
                                const transferId = message.transferId;
                                const file = activeFileTransfers.get(transferId);

                                if (file) {
                                    await transferFile(conn, file, transferId, message.chatId);
                                } else {
                                    conn.send(JSON.stringify({ type: 'error', message: 'File no longer available in sender memory' }));
                                }
                            }
                            else if (message.type === 'file-metadata') {
                                console.log('Receiving file metadata:', message);
                                fileMetadata = message;
                                totalChunks = message.totalChunks;
                                receivedChunks = [];
                                receivedChunksCount = 0;

                                showLargeFileDownloadModal(message.fileName, message.fileSize);
                            }
                            else if (message.type === 'file-complete') {
                                console.log('File transfer complete');

                                const blob = new Blob(receivedChunks, { type: fileMetadata?.fileType || 'application/octet-stream' });

                                if (fileMetadata?.transferId) {
                                    if (!window.receivedFileCache) window.receivedFileCache = new Map();
                                    window.receivedFileCache.set(fileMetadata.transferId, blob);
                                }

                                hideLargeFileDownloadModal();
                                showDeleteSuccessNotification('File received!');
                                await saveFileToDevice(blob, fileMetadata.fileName);

                                setTimeout(() => {
                                    if (conn.open) {
                                        conn.close();
                                    }
                                }, 3000);
                            }
                        }
                        else if (data instanceof ArrayBuffer) {
                            if (fileMetadata) {
                                receivedChunks.push(data);
                                receivedChunksCount++;

                                const progress = Math.round((receivedChunksCount / totalChunks) * 100);
                                updateDownloadProgress(progress, receivedChunksCount, totalChunks);
                            }
                        }
                    } catch (error) {
                        console.error('Error processing DataChannel data:', error);
                    }
                });

                conn.on('close', () => {
                    console.log('DataChannel connection closed');
                });

                conn.on('error', (err) => {
                    console.error('DataChannel error:', err);
                    hideLargeFileDownloadModal();
                    showToast('File transfer link error', 'error');
                });
            });
        }

        // ====== LOCATION FUNCTIONS ====== ///
        window.attachLocation = () => {
            attachmentMenu.classList.remove('active');
            openLocationPicker();
        };

        window.attachContact = () => {
            attachmentMenu.classList.remove('active');
            showToast('Contact sharing feature coming soon!', 'warning');
        };

        function openLocationPicker() {
            locationPickerModal.classList.add('active');
            locationPickerActive = true;

            useCurrentLocation();
            initSatelliteView();
        }

        function initSatelliteView() {
            const satelliteView = document.getElementById('satelliteView');
            satelliteView.innerHTML = `
                <div class="satellite-loading">
                    <div class="spinner"></div>
                    <p>Loading satellite view...</p>
                </div>
            `;

            setTimeout(() => {
                const satelliteView = document.getElementById('satelliteView');
                satelliteView.innerHTML = `
                    <div class="satellite-map">
                        <div class="map-grid">
                            <div class="grid-row">
                                <div class="grid-cell"></div>
                                <div class="grid-cell road"></div>
                                <div class="grid-cell building"></div>
                            </div>
                            <div class="grid-row">
                                <div class="grid-cell water"></div>
                                <div class="grid-cell"></div>
                                <div class="grid-cell"></div>
                            </div>
                            <div class="grid-row">
                                <div class="grid-cell"></div>
                                <div class="grid-cell"></div>
                                <div class="grid-cell park"></div>
                            </div>
                        </div>
                        <div class="location-marker">
                            <i class="fas fa-map-marker-alt"></i>
                        </div>
                    </div>
                `;
            }, 1000);
        }

        window.toggleSatelliteView = () => {
            const satelliteView = document.getElementById('satelliteView');
            const btn = document.querySelector('.satellite-btn');

            if (satelliteView.classList.contains('satellite-active')) {
                satelliteView.classList.remove('satellite-active');
                btn.innerHTML = '<i class="fas fa-satellite"></i> Satellite';
            } else {
                satelliteView.classList.add('satellite-active');
                btn.innerHTML = '<i class="fas fa-map"></i> Map';
            }
        };

        window.refreshLocation = () => {
            useCurrentLocation();
            showToast('Refreshing location...');
        };

        window.useCurrentLocation = () => {
            if (!navigator.geolocation) {
                showToast('Geolocation is not supported by your browser', 'error');
                return;
            }

            showToast('Getting your location with high accuracy...');

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const { latitude, longitude, accuracy } = position.coords;
                    currentLocation = { latitude, longitude, accuracy };

                    const accuracyInfo = document.getElementById('accuracyInfo');
                    if (!accuracyInfo) {
                        const satelliteView = document.getElementById('satelliteView');
                        satelliteView.insertAdjacentHTML('beforeend', `
                            <div class="accuracy-info" id="accuracyInfo">
                                <i class="fas fa-crosshairs"></i>
                                Accuracy: ${Math.round(accuracy)} meters
                            </div>
                        `);
                    } else {
                        accuracyInfo.innerHTML = `
                            <i class="fas fa-crosshairs"></i>
                            Accuracy: ${Math.round(accuracy)} meters
                        `;
                    }

                    try {
                        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`);
                        const data = await response.json();

                        if (data.display_name) {
                            locationSearch.value = data.display_name;

                            const addressElement = document.getElementById('satelliteAddress');
                            if (!addressElement) {
                                const satelliteView = document.getElementById('satelliteView');
                                satelliteView.insertAdjacentHTML('beforeend', `
                                    <div class="satellite-address" id="satelliteAddress">
                                        ${data.display_name.split(',')[0]}
                                    </div>
                                `);
                            }
                        } else {
                            locationSearch.value = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
                        }
                    } catch (error) {
                        console.error('Error getting address:', error);
                        locationSearch.value = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
                    }

                    showToast('Location found!');
                    updateLocationMarker(latitude, longitude);
                },
                (error) => {
                    console.error('Error getting location:', error);
                    showToast('Unable to get your location', 'error');
                    locationSearch.value = 'Location not available';

                    if (error.code === error.PERMISSION_DENIED) {
                        currentLocation = { latitude: 40.7128, longitude: -74.0060, accuracy: 100 };
                        locationSearch.value = 'New York, NY, USA';
                        updateLocationMarker(40.7128, -74.0060);
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                }
            );
        };

        function updateLocationMarker(lat, lng) {
            const marker = document.querySelector('.location-marker');
            if (marker) {
                marker.style.animation = 'none';
                setTimeout(() => {
                    marker.style.animation = 'bounce 0.5s ease';
                }, 10);
            }
        }

        window.sendLocation = async () => {
            if (!currentLocation) {
                showToast('Please get a location first', 'warning');
                return;
            }

            if (!currentChatId) {
                showToast('Please select a chat first', 'error');
                return;
            }

            const address = locationSearch.value.trim() || 'Shared Location';

            try {
                const locationData = {
                    chatId: currentChatId,
                    sender: currentUser.uid,
                    type: 'location',
                    latitude: currentLocation.latitude,
                    longitude: currentLocation.longitude,
                    address: address,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid],
                    delivered: false
                };

                await addDoc(collection(db, "messages"), locationData);

                const updateData = {
                    lastMessage: 'ðŸ“ Location',
                    lastMessageTime: serverTimestamp(),
                    sender: currentUser.uid
                };

                if (currentGroupId) {
                    updateData.readBy = [currentUser.uid];
                } else if (currentContact) {
                    updateData[`unreadCount.${currentContact.uid}`] = increment(1);
                }

                await updateDoc(doc(db, "chats", currentChatId), updateData);

                closeLocationPicker();
                showToast('Location shared successfully!');

            } catch (error) {
                console.error('Error sharing location:', error);
                showToast('Failed to share location', 'error');
            }
        };

        function closeLocationPicker() {
            locationPickerModal.classList.remove('active');
            locationPickerActive = false;
        }

        // ====== VOICE MESSAGE FUNCTIONS ======
        window.startVoiceRecording = () => {
            attachmentMenu.classList.remove('active');
            startVoiceMessage();
        };

        window.startVoiceMessage = async () => {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showToast('Voice recording not supported in your browser', 'error');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

                    const base64Data = await fileToBase64(audioBlob);

                    if (base64Data.length > 1000000) {
                        showToast('Voice message too long. Please record a shorter message.', 'error');
                        stream.getTracks().forEach(track => track.stop());
                        micButton.style.display = 'block';
                        sendButton.style.display = 'flex';
                        stopVoiceButton.style.display = 'none';
                        return;
                    }

                    const messageData = {
                        chatId: currentChatId,
                        sender: currentUser.uid,
                        type: 'voice',
                        content: base64Data,
                        duration: formatVoiceDuration(Date.now() - callStartTime),
                        timestamp: serverTimestamp(),
                        readBy: [currentUser.uid],
                        delivered: false
                    };

                    await addDoc(collection(db, "messages"), messageData);

                    const updateData = {
                        lastMessage: 'ðŸŽ¤ Voice message',
                        lastMessageTime: serverTimestamp(),
                        sender: currentUser.uid
                    };

                    if (currentGroupId) {
                        updateData.readBy = [currentUser.uid];
                    } else if (currentContact) {
                        updateData[`unreadCount.${currentContact.uid}`] = increment(1);
                    }

                    await updateDoc(doc(db, "chats", currentChatId), updateData);

                    stream.getTracks().forEach(track => track.stop());

                    showToast('Voice message sent!');
                };

                mediaRecorder.start();
                isRecording = true;
                callStartTime = Date.now();

                recordingAnimation.style.display = 'flex';
                micButton.style.display = 'none';
                sendButton.style.display = 'none';
                stopVoiceButton.style.display = 'flex';

            } catch (error) {
                console.error('Error starting voice recording:', error);
                showToast('Failed to access microphone. Please check permissions.', 'error');
            }
        };

        window.stopVoiceRecording = () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;

                recordingAnimation.style.display = 'none';
                micButton.style.display = 'block';
                sendButton.style.display = 'flex';
                stopVoiceButton.style.display = 'none';
            }
        };

        window.playVoiceMessage = (base64Data) => {
            try {
                const audio = new Audio(base64Data);
                audio.play().catch(e => console.error('Error playing voice message:', e));
            } catch (error) {
                console.error('Error playing voice message:', error);
                showToast('Failed to play voice message', 'error');
            }
        };

        function formatVoiceDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // ====== CAMERA TOGGLE FUNCTION ======
        window.toggleCamera = async () => {
            if (!localStream || !isInCall || currentCallType !== 'video') {
                return;
            }

            try {
                // Get available cameras
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                if (videoDevices.length < 2) {
                    showToast('Only one camera available', 'warning');
                    return;
                }

                // Find current camera index
                let currentIndex = -1;
                for (let i = 0; i < videoDevices.length; i++) {
                    if (videoDevices[i].deviceId === localStream.getVideoTracks()[0].getSettings().deviceId) {
                        currentIndex = i;
                        break;
                    }
                }

                // Switch to next camera
                const nextIndex = (currentIndex + 1) % videoDevices.length;
                const nextDevice = videoDevices[nextIndex];

                // Stop current video tracks
                localStream.getVideoTracks().forEach(track => track.stop());

                // Get new stream with specific device
                const constraints = {
                    video: { deviceId: { exact: nextDevice.deviceId } },
                    audio: true
                };

                const newStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Replace the video track in the local stream
                const newVideoTrack = newStream.getVideoTracks()[0];
                const sender = activeCall.peerConnection.getSenders().find(s =>
                    s.track && s.track.kind === 'video'
                );

                if (sender) {
                    sender.replaceTrack(newVideoTrack);
                }

                // Update local video display
                localVideo.srcObject = newStream;

                // Replace old video track with new one in localStream
                const oldVideoTrack = localStream.getVideoTracks()[0];
                localStream.removeTrack(oldVideoTrack);
                localStream.addTrack(newVideoTrack);

                // Determine camera type for toast message
                const facingMode = newVideoTrack.getSettings().facingMode;
                const cameraType = facingMode === 'user' ? 'front' : 'back';
                showToast(`Switched to ${cameraType} camera`);

                // Update camera toggle icon (rotate icon when multiple cameras available)
                const cameraToggleIcon = document.getElementById('cameraToggleIcon');
                if (cameraToggleIcon) {
                    cameraToggleIcon.className = videoDevices.length > 2 ? 'fas fa-camera-rotate' : 'fas fa-camera';
                }

            } catch (error) {
                console.error('Error toggling camera:', error);
                showToast('Failed to switch camera', 'error');
            }
        };

        // ====== PEERJS CALLING FUNCTIONS ======
        function initializePeer() {
            if (!currentUser) return;

            const peerId = `webchat_${currentUser.uid.substring(0, 8)}_${Date.now().toString(36)}`;

            console.log('Initializing PeerJS with ID:', peerId);

            if (peer) {
                try {
                    peer.destroy();
                } catch (e) {
                    console.log('Error destroying old peer:', e);
                }
                peer = null;
            }

            peer = new Peer(peerId, {
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10
                },
                debug: 2
            });

            peer.on('open', async (id) => {
                console.log('âœ… PeerJS connected with ID:', id);
                currentPeerId = id;
                await savePeerId(id);
                updateNetworkStatus(true, 'Connected to P2P network');

                initializeDataChannelHandlers();
            });

            peer.on('error', (err) => {
                console.error('âŒ PeerJS error:', err);

                if (err.type === 'peer-unavailable') {
                    updateNetworkStatus(false, 'Contact unavailable');
                    showToast('Contact is not available for calls', 'error');
                } else if (err.type === 'network') {
                    updateNetworkStatus(false, 'Network error');
                } else if (err.type === 'browser-incompatible') {
                    showToast('Your browser does not support WebRTC', 'error');
                }

                if (err.type === 'disconnected' || err.type === 'server-error') {
                    console.log('Attempting to reconnect to PeerJS...');
                    setTimeout(() => {
                        if (peer && (peer.disconnected || peer.destroyed)) {
                            initializePeer();
                        }
                    }, 3000);
                }
            });

            peer.on('disconnected', () => {
                console.log('âš ï¸ PeerJS disconnected');
                updateNetworkStatus(false, 'Disconnected from P2P');

                setTimeout(() => {
                    if (peer && peer.disconnected) {
                        console.log('Reconnecting to PeerJS...');
                        peer.reconnect();
                    }
                }, 5000);
            });

            peer.on('call', (call) => {
                console.log('ðŸ“ž Incoming call received from:', call.peer);

                const metadata = call.metadata || {};
                incomingCallData = {
                    call: call,
                    callerId: metadata.callerId,
                    callerName: metadata.callerName,
                    callType: metadata.callType || 'audio',
                    timestamp: Date.now(),
                    metadata: metadata
                };

                handleIncomingCall(call);
            });
        }

        async function savePeerId(peerId) {
            if (!currentUser) return;

            try {
                const userRef = doc(db, "users", currentUser.uid);
                await updateDoc(userRef, {
                    peerId: peerId,
                    lastOnline: serverTimestamp(),
                    online: true,
                    peerIdUpdated: serverTimestamp()
                });
                console.log('âœ… Peer ID saved to database:', peerId);
            } catch (error) {
                console.error('âŒ Error saving peer ID:', error);
            }
        }

        async function getContactPeerId(contactId) {
            try {
                const userDoc = await getDoc(doc(db, "users", contactId));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    if (userData.peerId) {
                        console.log('âœ… Found peer ID for contact:', userData.peerId);
                        return userData.peerId;
                    }
                }
            } catch (error) {
                console.error('âŒ Error getting contact peer ID:', error);
            }

            try {
                await updateDoc(doc(db, "users", contactId), {
                    online: false,
                    lastSeen: serverTimestamp()
                });
            } catch (e) {
                console.log('Could not update contact status:', e);
            }

            return null;
        }

        // ====== CALLING SYSTEM ======
        window.startAudioCall = () => startCall('audio');
        window.startVideoCall = () => startCall('video');

        async function startCall(type) {
            if (!currentContact && !currentGroupId) {
                showToast('Please select a contact or group first', 'error');
                return;
            }

            if (!peer || !peer.id) {
                showToast('Initializing connection...', 'warning');
                setTimeout(() => startCall(type), 1000);
                return;
            }

            if (isInCall) {
                showToast('You are already in a call', 'warning');
                return;
            }

            const isGroup = !!currentGroupId;
            console.log(`ðŸ“ž Starting ${type} ${isGroup ? 'Group ' : ''}call...`);

            try {
                const constraints = {
                    audio: true,
                    video: type === 'video'
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);

                if (isGroup) {
                    const groupDoc = await getDoc(doc(db, "chats", currentChatId));
                    if (!groupDoc.exists()) return;
                    const participants = groupDoc.data().participants.filter(pid => pid !== currentUser.uid);

                    videoGrid.style.display = 'grid';
                    videoGrid.innerHTML = '';
                    remoteVideoContainer.style.display = 'none';
                    callContactInfo.style.display = 'none';

                    // Add local video to grid
                    addVideoToGrid(localStream, 'You (Me)', true);

                    for (const pid of participants) {
                        const contactPeerId = await getContactPeerId(pid);
                        if (contactPeerId) {
                            const metadata = {
                                callerId: currentUser.uid,
                                callerName: await getUserName(currentUser.uid),
                                callType: type,
                                chatId: currentChatId,
                                isGroup: true,
                                groupId: currentChatId
                            };
                            const call = peer.call(contactPeerId, localStream, { metadata });
                            handleCallEvents(call, await getUserName(pid));
                        }
                    }
                } else {
                    // 1:1 Call (existing logic)
                    const contactPeerId = await getContactPeerId(currentContact.uid);
                    if (!contactPeerId) {
                        showToast('Contact is not available', 'error');
                        return;
                    }
                    const metadata = {
                        callerId: currentUser.uid,
                        callerName: await getUserName(currentUser.uid),
                        callType: type,
                        chatId: currentChatId
                    };
                    const call = peer.call(contactPeerId, localStream, { metadata });
                    handleCallEvents(call, currentContact.name);
                }

                isInCall = true;
                currentCallType = type;
                callInterface.classList.add('active');
                if (type === 'audio') callInterface.classList.add('audio-call-interface');

            } catch (err) {
                console.error(err);
                showToast('Call failed check your permissions', 'error');
            }
        }

        function addVideoToGrid(stream, name, isLocal = false) {
            const box = document.createElement('div');
            box.className = 'video-box';
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            if (isLocal) video.muted = true;
            video.srcObject = stream;

            const label = document.createElement('div');
            label.className = 'video-label';
            label.textContent = name;

            box.appendChild(video);
            box.appendChild(label);
            videoGrid.appendChild(box);
        }

        function handleCallEvents(call, name) {
            call.on('stream', (remoteStream) => {
                console.log('âœ… Received remote stream');

                if (currentGroupId) {
                    // Group call - add to grid
                    addVideoToGrid(remoteStream, name);
                } else {
                    // 1:1 call - handle based on call type
                    if (currentCallType === 'video') {
                        // Video call
                        remoteVideo.srcObject = remoteStream;
                        remoteVideoContainer.style.display = 'block';
                        callContactInfo.style.display = 'none';

                        // Show local video
                        localVideo.srcObject = localStream;
                        localVideoContainer.style.display = 'block';

                        // Show camera toggle
                        cameraToggleBtn.style.display = 'flex';
                        floatingCameraToggle.style.display = 'flex';
                    } else {
                        // Audio call
                        remoteAudio.srcObject = remoteStream;
                        remoteVideoContainer.style.display = 'none';
                        localVideoContainer.style.display = 'none';
                        cameraToggleBtn.style.display = 'none';
                        floatingCameraToggle.style.display = 'none';
                    }

                    callStatus.textContent = 'Connected';
                    startCallTimer();
                }
            });
            call.on('close', () => {
                console.log('ðŸ“ž Call closed');
                handleCallEnded();
            });
            call.on('error', (err) => {
                console.error('âŒ Call error:', err);
                handleCallError(err);
            });
        }

        function handleIncomingCall(call) {
            console.log('Handling incoming call from:', call.peer);

            const metadata = call.metadata || {};
            const callerId = metadata.callerId;
            const callerName = metadata.callerName || 'Unknown';
            const callType = metadata.callType || 'audio';

            incomingCallData = {
                call: call,
                callerId: callerId,
                callerName: callerName,
                callType: callType,
                timestamp: Date.now()
            };

            console.log('Incoming call data:', incomingCallData);

            loadProfilePicture(callerId).then(profilePic => {
                if (profilePic) {
                    incomingCallAvatar.style.backgroundImage = `url(${profilePic})`;
                    incomingCallAvatar.textContent = '';
                } else {
                    incomingCallAvatar.style.backgroundImage = '';
                    incomingCallAvatar.textContent = callerName.charAt(0);
                }
            });

            incomingCallName.textContent = callerName;
            incomingCallType.textContent = metadata.isGroup ? `Group ${callType === 'video' ? 'Video' : 'Voice'} Call` : (callType === 'video' ? 'Video Call' : 'Voice Call');
            incomingCallModal.classList.add('active');

            startRingtone();
            triggerVibration();
        }

        function startRingtone() {
            stopRingtone();
            isRinging = true;

            // Better ringtone sound
            ringtoneSound.src = 'https://assets.mixkit.co/sfx/preview/mixkit-classic-alarm-995.mp3';
            ringtoneSound.loop = true;
            ringtoneSound.volume = 0.6;

            ringtoneSound.play().catch(e => {
                console.log('Ringtone play failed:', e);
            });

            // Vibration pattern
            if ('vibrate' in navigator) {
                ringtoneInterval = setInterval(() => {
                    navigator.vibrate([500, 500, 500, 500]);
                }, 2000);
            }
        }

        function stopRingtone() {
            isRinging = false;
            ringtoneSound.pause();
            ringtoneSound.currentTime = 0;

            if (ringtoneInterval) {
                clearInterval(ringtoneInterval);
                ringtoneInterval = null;
            }

            if ('vibrate' in navigator) {
                navigator.vibrate(0);
            }
        }

        function triggerVibration() {
            if ('vibrate' in navigator) {
                navigator.vibrate([500, 500, 500, 500]);
            }
        }

        function stopVibration() {
            if ('vibrate' in navigator) {
                navigator.vibrate(0);
            }
        }

        function playMessageSound(type) {
            try {
                if (type === 'send') {
                    messageSound.src = 'https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3';
                } else {
                    messageSound.src = 'https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-tone-2870.mp3';
                }
                messageSound.volume = 0.3;
                messageSound.currentTime = 0;
                messageSound.play().catch(e => console.log('Message sound failed:', e));
            } catch (error) {
                console.log('Error playing message sound:', error);
            }
        }

        window.acceptCall = async () => {
            if (!incomingCallData || !incomingCallData.call) {
                showToast('No incoming call to accept', 'error');
                return;
            }

            console.log('âœ… Accepting call from:', incomingCallData.callerName);

            stopRingtone();
            stopVibration();
            incomingCallModal.classList.remove('active');

            try {
                const constraints = {
                    audio: true,
                    video: incomingCallData.callType === 'video'
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('âœ… User media obtained for answering call');

                incomingCallData.call.answer(localStream);
                console.log('ðŸ“ž Call answered');

                incomingCallData.call.on('stream', (stream) => {
                    console.log('ðŸ“¹ Received remote stream');
                    remoteStream = stream;

                    if (incomingCallData.metadata && incomingCallData.metadata.isGroup) {
                        videoGrid.style.display = 'grid';
                        videoGrid.innerHTML = '';
                        remoteVideoContainer.style.display = 'none';
                        callContactInfo.style.display = 'none';
                        addVideoToGrid(localStream, 'You (Me)', true);
                        addVideoToGrid(stream, incomingCallData.callerName);
                    } else if (incomingCallData.callType === 'video') {
                        remoteVideo.srcObject = stream;
                        remoteVideoContainer.style.display = 'block';
                        callContactInfo.style.display = 'none';

                        // Show camera toggle button for video calls
                        cameraToggleBtn.style.display = 'flex';
                        floatingCameraToggle.style.display = 'flex';

                        localVideo.srcObject = localStream;
                        localVideoContainer.style.display = 'block';
                    } else {
                        remoteAudio.srcObject = stream;
                        cameraToggleBtn.style.display = 'none';
                        floatingCameraToggle.style.display = 'none';
                    }

                    if (incomingCallData.callType === 'audio') {
                        callInterface.classList.add('audio-call-interface');
                    }
                });

                incomingCallData.call.on('close', () => {
                    console.log('ðŸ“ž Call closed by remote');
                    handleCallEnded();
                });

                incomingCallData.call.on('error', (err) => {
                    console.error('âŒ Call error after accepting:', err);
                    handleCallError(err);
                });

                activeCall = incomingCallData.call;
                isInCall = true;
                currentCallType = incomingCallData.callType;
                currentContact = {
                    uid: incomingCallData.callerId,
                    name: incomingCallData.callerName
                };

                const profilePic = await loadProfilePicture(incomingCallData.callerId);
                if (profilePic) {
                    callAvatar.style.backgroundImage = `url(${profilePic})`;
                    callAvatar.textContent = '';
                } else {
                    callAvatar.style.backgroundImage = '';
                    callAvatar.textContent = incomingCallData.callerName?.charAt(0) || 'C';
                }

                callStatus.textContent = 'Connected';
                callInterface.classList.add('active');

                startCallTimer();
                sendCallNotification('accepted');

            } catch (error) {
                console.error('âŒ Error accepting call:', error);
                showToast('Error accepting call: ' + error.message, 'error');
                handleCallEnded();
            }

            incomingCallData = null;
        };

        window.rejectCall = () => {
            console.log('âŒ Rejecting call');

            stopRingtone();
            stopVibration();

            if (incomingCallData && incomingCallData.call) {
                try {
                    incomingCallData.call.close();
                } catch (e) {
                    console.log('Error closing call on reject:', e);
                }
            }

            incomingCallModal.classList.remove('active');
            incomingCallData = null;

            if (currentChatId) {
                sendCallNotification('rejected');
            }
        };

        window.endCall = () => {
            console.log('ðŸ“ž Ending call');
            handleCallEnded();
            showDeleteSuccessNotification('Call ended');
        };

        window.cancelOutgoingCall = () => {
            console.log('âŒ Cancelling outgoing call');

            if (outgoingCallTimeout) {
                clearTimeout(outgoingCallTimeout);
                outgoingCallTimeout = null;
            }

            if (outgoingCallData && outgoingCallData.call) {
                try {
                    outgoingCallData.call.close();
                } catch (e) {
                    console.log('Error closing outgoing call:', e);
                }
            }

            outgoingCallModal.classList.remove('active');
            outgoingCallData = null;

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (currentContact) {
                sendCallNotification('cancelled');
            }

            showToast('Call cancelled', 'warning');
        };

        function handleCallEnded() {
            console.log('Handling call ended');

            if (outgoingCallTimeout) {
                clearTimeout(outgoingCallTimeout);
                outgoingCallTimeout = null;
            }

            try {
                stopRingtone();
            } catch (e) {
                console.log('Error stopping ringtone:', e);
            }
            outgoingCallModal.classList.remove('active');
            incomingCallModal.classList.remove('active');
            callInterface.classList.remove('active');

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            if (activeCall) {
                try {
                    activeCall.close();
                } catch (e) {
                    console.log('Error closing active call:', e);
                }
                activeCall = null;
            }

            remoteAudio.srcObject = null;
            remoteVideo.srcObject = null;
            localVideo.srcObject = null;

            remoteVideoContainer.style.display = 'none';
            localVideoContainer.style.display = 'none';
            callContactInfo.style.display = 'block';

            // Hide camera toggle buttons
            cameraToggleBtn.style.display = 'none';
            floatingCameraToggle.style.display = 'none';

            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }

            try {
                stopVibration();
            } catch (e) {
                console.log('Error stopping vibration:', e);
            }

            isInCall = false;
            isMuted = false;
            isVideoOff = false;
            callInitiator = false;
            if (typeof currentCamera !== 'undefined') {
                currentCamera = 'user';
            }

            document.getElementById('muteIcon').className = 'fas fa-microphone-slash';
            document.getElementById('videoIcon').className = 'fas fa-video-slash';

            incomingCallData = null;
            outgoingCallData = null;

            if (currentContact && callStartTime) {
                sendCallNotification('ended');
            }

            console.log('Call cleanup complete');
        }

        function handleCallError(error) {
            console.error('Call error occurred:', error);
            showToast('Call failed: ' + (error.message || 'Unknown error'), 'error');
            handleCallEnded();
        }

        function startCallTimer() {
            callStartTime = Date.now();
            callTimer = setInterval(() => {
                const elapsed = Date.now() - callStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                callTimerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        async function sendCallNotification(status) {
            if (!currentChatId || !currentContact) return;

            try {
                let callMessage;
                const callDuration = callStartTime ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
                const minutes = Math.floor(callDuration / 60);
                const seconds = callDuration % 60;

                switch (status) {
                    case 'ended':
                        callMessage = `ðŸ“ž Call ended ${minutes > 0 ? `${minutes}m ` : ''}${seconds}s`;
                        break;
                    default:
                        // Skip other call statuses
                        return;
                }

                await addDoc(collection(db, "messages"), {
                    chatId: currentChatId,
                    sender: "system",
                    text: callMessage,
                    timestamp: serverTimestamp(),
                    type: "system",
                    canDeleteForEveryone: true
                });

                console.log('ðŸ“ Call notification sent:', callMessage);
            } catch (error) {
                console.error('Error sending call notification:', error);
            }
        }

        window.toggleMute = () => {
            if (!localStream) return;

            isMuted = !isMuted;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isMuted;
            });

            const muteIcon = document.getElementById('muteIcon');
            muteIcon.className = isMuted ? 'fas fa-microphone' : 'fas fa-microphone-slash';
            console.log('ðŸŽ¤ Microphone', isMuted ? 'muted' : 'unmuted');

            showToast(isMuted ? 'Microphone muted' : 'Microphone unmuted');
        };

        window.toggleVideo = () => {
            if (!localStream || currentCallType !== 'video') return;

            isVideoOff = !isVideoOff;
            localStream.getVideoTracks().forEach(track => {
                track.enabled = !isVideoOff;
            });

            const videoIcon = document.getElementById('videoIcon');
            videoIcon.className = isVideoOff ? 'fas fa-video' : 'fas fa-video-slash';
            localVideoContainer.style.display = isVideoOff ? 'none' : 'block';
            console.log('ðŸ“¹ Camera', isVideoOff ? 'off' : 'on');

            showToast(isVideoOff ? 'Camera turned off' : 'Camera turned on');
        };

        // ====== GROUP CHAT FUNCTIONS ======
        window.showNewGroupModal = () => {
            groupCreationModal.classList.add('active');
            selectedGroupMembers.clear();
            groupNameInput.value = '';
            updateGroupCreationStats();
            loadGroupMembers();
        };

        window.closeGroupCreationModal = () => {
            groupCreationModal.classList.remove('active');
            selectedGroupMembers.clear();
            groupNameInput.value = '';
            groupMembersList.innerHTML = '';
            updateGroupCreationStats();
        };

        // Update group creation stats
        function updateGroupCreationStats() {
            selectedMembersCount.textContent = selectedGroupMembers.size;
            groupNameLength.textContent = groupNameInput.value.length;

            // Update create button state
            if (groupNameInput.value.trim() && selectedGroupMembers.size > 0) {
                createGroupBtn.disabled = false;
            } else {
                createGroupBtn.disabled = true;
            }
        }

        // Listen for group name input
        groupNameInput.addEventListener('input', updateGroupCreationStats);

        async function loadGroupMembers() {
            groupMembersList.innerHTML = '<div class="spinner"></div>';

            try {
                const usersQuery = query(collection(db, "users"));
                const snapshot = await getDocs(usersQuery);

                if (snapshot.empty) {
                    groupMembersList.innerHTML = `
                        <div class="no-results" style="padding: 20px;">
                            <p>No contacts found</p>
                        </div>
                    `;
                    return;
                }

                groupMembersList.innerHTML = '';

                snapshot.forEach((userDoc) => {
                    const user = userDoc.data();

                    if (user.uid === currentUser.uid) return;

                    renderGroupMember(user);
                });

            } catch (error) {
                console.error('Error loading group members:', error);
                groupMembersList.innerHTML = `
                    <div class="no-results" style="padding: 20px;">
                        <p>Error loading contacts</p>
                    </div>
                `;
            }
        }

        function renderGroupMember(user) {
            const profilePicture = user.profilePicture;
            const avatarStyle = profilePicture
                ? `background-image: url(${profilePicture}); background-size: cover; background-position: center;`
                : `background-color: ${user.avatarColor || '#25D366'}`;

            const avatarContent = profilePicture ? '' : user.name.charAt(0).toUpperCase();

            const memberItem = document.createElement('div');
            memberItem.className = 'group-member-select';
            memberItem.dataset.userId = user.uid;
            memberItem.onclick = () => toggleGroupMember(user.uid, memberItem);

            memberItem.innerHTML = `
                <div class="group-member-checkbox"></div>
                <div class="chat-avatar" style="width: 40px; height: 40px; ${avatarStyle}">
                    ${avatarContent}
                </div>
                <div class="search-result-info">
                    <div class="search-result-name">${user.name}</div>
                    <div class="search-result-email">${user.email}</div>
                </div>
            `;

            groupMembersList.appendChild(memberItem);
        }

        function toggleGroupMember(userId, memberItem) {
            if (selectedGroupMembers.has(userId)) {
                selectedGroupMembers.delete(userId);
                memberItem.classList.remove('selected');
            } else {
                selectedGroupMembers.add(userId);
                memberItem.classList.add('selected');
            }

            const checkbox = memberItem.querySelector('.group-member-checkbox');
            checkbox.checked = selectedGroupMembers.has(userId);

            updateGroupCreationStats();
        }

        window.createNewGroup = async () => {
            const groupName = groupNameInput.value.trim();

            if (!groupName) {
                showToast('Please enter a group name', 'error');
                return;
            }

            if (selectedGroupMembers.size === 0) {
                showToast('Please select at least one member', 'error');
                return;
            }

            try {
                const groupId = `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const participants = [currentUser.uid, ...Array.from(selectedGroupMembers)];

                await setDoc(doc(db, "chats", groupId), {
                    id: groupId,
                    isGroup: true,
                    groupName: groupName,
                    participants: participants,
                    createdBy: currentUser.uid,
                    createdAt: serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: serverTimestamp(),
                    readBy: [currentUser.uid],
                    typing: {},
                    unreadCount: {},
                    avatarColor: getRandomColor()
                });

                await addDoc(collection(db, "messages"), {
                    chatId: groupId,
                    sender: "system",
                    text: `${await getUserName(currentUser.uid)} created group "${groupName}"`,
                    timestamp: serverTimestamp(),
                    type: "system"
                });

                closeGroupCreationModal();
                showDeleteSuccessNotification('Group created successfully!');

                loadChats();

            } catch (error) {
                console.error('Error creating group:', error);
                showToast('Failed to create group. Please try again.', 'error');
            }
        };

        // ====== PROFILE FUNCTIONS ======
        window.showProfileModal = () => {
            profileModal.classList.add('active');
            loadProfileData();
        };

        window.enableProfileEdit = () => {
            profileNameDisplay.style.display = 'none';
            profileForm.style.display = 'block';
            profileNameInput.value = profileNameText.textContent;
            profileEmailInput.value = profileEmailText.textContent;
            profileNameInput.focus();
        };

        window.cancelProfileEdit = () => {
            profileForm.style.display = 'none';
            profileNameDisplay.style.display = 'flex';
        };

        window.saveProfile = async () => {
            const newName = profileNameInput.value.trim();
            const newEmail = profileEmailInput.value.trim();

            if (!newName) {
                showToast('Please enter your name', 'error');
                return;
            }

            try {
                await updateDoc(doc(db, "users", currentUser.uid), {
                    name: newName,
                    email: newEmail || currentUser.email
                });

                profileNameText.textContent = newName;
                profileEmailText.textContent = newEmail || currentUser.email;

                if (!userProfilePicture) {
                    userAvatar.textContent = newName.charAt(0).toUpperCase();
                    profileAvatarText.textContent = newName.charAt(0).toUpperCase();
                }

                cancelProfileEdit();
                showDeleteSuccessNotification('Profile updated successfully!');

                loadChats();

            } catch (error) {
                console.error('Error updating profile:', error);
                showToast('Failed to update profile. Please try again.', 'error');
            }
        };

        async function loadProfileData() {
            if (!currentUser) return;

            try {
                const userDoc = await getDoc(doc(db, "users", currentUser.uid));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    profileNameText.textContent = userData.name || currentUser.email.split('@')[0];
                    profileEmailText.textContent = userData.email || currentUser.email;

                    if (userData.profilePicture) {
                        userProfilePicture = userData.profilePicture;
                        updateProfilePicture(userData.profilePicture);
                    } else {
                        const userName = userData.name || currentUser.email.split('@')[0];
                        profileAvatarText.textContent = userName.charAt(0).toUpperCase();
                        profileAvatarLarge.style.backgroundImage = '';
                    }

                    profileAvatarLarge.style.backgroundColor = userData.avatarColor || '#25D366';
                }
            } catch (error) {
                console.error('Error loading profile data:', error);
            }
        }

        window.changeProfilePicture = () => {
            profileUploadModal.classList.add('active');
        };

        window.closeProfileUpload = () => {
            profileUploadModal.classList.remove('active');
        };

        window.uploadProfilePictureFromGallery = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await handleProfilePictureUpload(file);
                }
            };
            input.click();
            closeProfileUpload();
        };

        window.takeProfilePicture = () => {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showToast('Camera access not available', 'error');
                return;
            }

            showToast('Camera feature requires additional implementation', 'warning');
            closeProfileUpload();
        };

        window.removeProfilePicture = () => {
            if (confirm('Are you sure you want to remove your profile picture?')) {
                userProfilePicture = null;
                updateProfilePicture(null);
                showDeleteSuccessNotification('Profile picture removed');
            }
            closeProfileUpload();
        };

        async function compressImage(file, maxWidth = 800, maxHeight = 800, quality = 0.7) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height *= maxWidth / width;
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width *= maxHeight / height;
                                height = maxHeight;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                };
            });
        }

        async function handleProfilePictureUpload(file) {
            if (file.size > 5 * 1024 * 1024) {
                showToast('Profile picture must be less than 5MB', 'error');
                return;
            }

            try {
                showToast('Processing image...', 'info');
                const compressedBase64 = await compressImage(file);

                // Final check - ensure it's still under ~1MB for Firestore
                if (compressedBase64.length > 1000000) {
                    showToast('Image still too large after compression. Please try a smaller file.', 'error');
                    return;
                }

                userProfilePicture = compressedBase64;

                await updateDoc(doc(db, "users", currentUser.uid), {
                    profilePicture: compressedBase64,
                    profilePictureUpdated: serverTimestamp()
                });

                updateProfilePicture(compressedBase64);

                showDeleteSuccessNotification('Profile picture updated!');

            } catch (error) {
                console.error('Error uploading profile picture:', error);
                showToast('Failed to upload profile picture', 'error');
            }
        }

        function updateProfilePicture(base64Data) {
            if (userAvatar) {
                if (base64Data) {
                    userAvatar.style.backgroundImage = `url(${base64Data})`;
                    userAvatar.textContent = '';
                } else {
                    userAvatar.style.backgroundImage = '';
                    const userName = profileNameText.textContent || 'U';
                    userAvatar.textContent = userName.charAt(0).toUpperCase();
                }
            }

            if (profileAvatarLarge) {
                if (base64Data) {
                    profileAvatarLarge.style.backgroundImage = `url(${base64Data})`;
                    profileAvatarText.textContent = '';
                } else {
                    profileAvatarLarge.style.backgroundImage = '';
                    const userName = profileNameText.textContent || 'U';
                    profileAvatarText.textContent = userName.charAt(0).toUpperCase();
                }
            }
        }

        async function loadProfilePicture(userId) {
            try {
                const userDoc = await getDoc(doc(db, "users", userId));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    return userData.profilePicture || null;
                }
            } catch (error) {
                console.error('Error loading profile picture:', error);
            }
            return null;
        }

        // ====== DELETE FUNCTIONS ======
        window.showDeleteModal = (messageId, messageText) => {
            messageToDelete = messageId;
            currentMessageData = null;
            deleteOption = null;

            deleteForEveryone.classList.remove('selected');
            deleteForMe.classList.remove('selected');
            confirmDeleteBtn.disabled = true;

            if (messageText && messageText.length > 50) {
                messageText = messageText.substring(0, 50) + '...';
            }
            deleteModalText.innerHTML = `Select how you want to delete this message:<br><br>"${escapeHtml(messageText || 'This message')}"`;
            deleteModal.classList.add('active');

            loadMessageData(messageId);
        };

        window.selectDeleteOption = (option) => {
            deleteOption = option;

            deleteForEveryone.classList.remove('selected');
            deleteForMe.classList.remove('selected');

            if (option === 'everyone') {
                deleteForEveryone.classList.add('selected');
                confirmDeleteBtn.disabled = false;
            } else if (option === 'me') {
                deleteForMe.classList.add('selected');
                confirmDeleteBtn.disabled = false;
            }
        };

        window.cancelDelete = () => {
            messageToDelete = null;
            deleteOption = null;
            currentMessageData = null;
            deleteModal.classList.remove('active');
        };

        window.confirmDelete = async () => {
            if (!messageToDelete || !currentChatId || !deleteOption) {
                showToast('Please select a delete option', 'error');
                return;
            }

            try {
                const messageDoc = await getDoc(doc(db, "messages", messageToDelete));
                if (!messageDoc.exists()) {
                    showToast('Message not found', 'error');
                    deleteModal.classList.remove('active');
                    return;
                }

                const messageData = messageDoc.data();

                const isSender = messageData.sender === currentUser.uid;
                const isSystemMessage = messageData.type === 'system' && messageData.canDeleteForEveryone;

                if (deleteOption === 'everyone') {
                    if (!isSender && !isSystemMessage) {
                        showToast('You can only delete your own messages for everyone', 'error');
                        deleteModal.classList.remove('active');
                        return;
                    }

                    await deleteDoc(doc(db, "messages", messageToDelete));

                    const chatDoc = await getDoc(doc(db, "chats", currentChatId));
                    if (chatDoc.exists()) {
                        const chatData = chatDoc.data();

                        if (messageData.text && messageData.text === chatData.lastMessage) {
                    // Fetch the previous message (use a simplified query without composite index)
                    const allMessagesRef = collection(db, "messages");
                    const allMessagesQuery = query(
                        allMessagesRef,
                        where("chatId", "==", currentChatId)
                    );
                    
                    const allSnapshot = await getDocs(allMessagesQuery);
                    let newLastMessage = 'No messages yet';
                    let newLastMessageTime = serverTimestamp();

                    // Filter and sort in JavaScript to avoid composite index requirement
                    const messages = [];
                    allSnapshot.forEach((doc) => {
                        messages.push({id: doc.id, ...doc.data()});
                    });
                    
                    messages.sort((a, b) => (b.timestamp?.toMillis?.() || 0) - (a.timestamp?.toMillis?.() || 0));

                    if (messages.length > 0) {
                        const msg = messages[0];
                        if (msg.type === 'image') {
                            newLastMessage = 'ðŸ“· Photo';
                        } else if (msg.type === 'video') {
                            newLastMessage = 'ðŸŽ¬ Video';
                        } else if (msg.type === 'voice') {
                            newLastMessage = 'ðŸŽ¤ Voice message';
                        } else if (msg.type === 'document') {
                            newLastMessage = 'ðŸ“„ Document';
                        } else if (msg.type === 'location') {
                            newLastMessage = 'ðŸ“ Location';
                        } else if (msg.text && msg.type !== 'system') {
                            newLastMessage = msg.text;
                        }
                        newLastMessageTime = msg.timestamp;
                    }

                            await updateDoc(doc(db, "chats", currentChatId), {
                                lastMessage: newLastMessage,
                                lastMessageTime: newLastMessageTime
                            });
                        }
                    }

                    showDeleteSuccessNotification('Message deleted for everyone');

                } else if (deleteOption === 'me') {
                    await updateDoc(doc(db, "messages", messageToDelete), {
                        deletedFor: arrayUnion(currentUser.uid)
                    });

                    showDeleteSuccessNotification('Message deleted for you');
                }

                deleteModal.classList.remove('active');

                setTimeout(() => {
                    messageToDelete = null;
                    deleteOption = null;
                    currentMessageData = null;
                }, 100);

            } catch (error) {
                console.error('âŒ Error deleting message:', error);
                showToast('Failed to delete message. Please try again.', 'error');
                deleteModal.classList.remove('active');
            }
        };

        window.showDeleteChatModal = (chatId, event) => {
            if (event) event.stopPropagation();
            chatToDelete = chatId;
            deleteChatModal.classList.add('active');
        };

        window.confirmChatDelete = async () => {
            if (!chatToDelete) return;

            try {
                const chatDoc = await getDoc(doc(db, "chats", chatToDelete));
                if (chatDoc.exists()) {
                    // Delete all messages in the chat
                    const messagesQuery = query(
                        collection(db, "messages"),
                        where("chatId", "==", chatToDelete)
                    );

                    const messagesSnapshot = await getDocs(messagesQuery);
                    const deletePromises = [];

                    messagesSnapshot.forEach((doc) => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });

                    // Wait for all messages to be deleted
                    await Promise.all(deletePromises);

                    // Now delete the chat document
                    await deleteDoc(doc(db, "chats", chatToDelete));

                    showDeleteSuccessNotification('Chat deleted successfully!');
                } else {
                    showToast('Chat not found', 'error');
                }

                // Close chat if it's currently open
                if (currentChatId === chatToDelete) {
                    currentChatId = null;
                    currentContact = null;
                    currentGroupId = null;
                    contactName.textContent = 'Select a chat';
                    contactStatus.textContent = 'Click on a chat to start messaging';
                    contactAvatar.textContent = 'C';
                    contactAvatar.style.backgroundImage = '';
                    messagesContainer.innerHTML = `
                        <div class="empty-chat">
                            <div class="empty-chat-icon">
                                <i class="fas fa-comment-slash"></i>
                            </div>
                            <h3>No chat selected</h3>
                            <p>Select a chat from the list or search for a user to start messaging.</p>
                        </div>
                    `;
                    if (window.innerWidth <= 768) {
                        showChatList();
                    }
                }

                deleteChatModal.classList.remove('active');
                chatToDelete = null;

                // Reload chats to update the list
                loadChats();

            } catch (error) {
                console.error('Error deleting chat:', error);
                showToast('Failed to delete chat. Please try again.', 'error');
            }
        };

        window.cancelChatDelete = () => {
            chatToDelete = null;
            deleteChatModal.classList.remove('active');
        };

        // ====== UTILITY FUNCTIONS ======
        function getRandomColor() {
            const colors = ['#25D366', '#128C7E', '#075E54', '#34B7F1', '#FF5733', '#C70039', '#900C3F', '#581845'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function formatTime(date) {
            if (!date) return '';

            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;

            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function processMessageText(text) {
            if (!text) return '';

            // URL regex pattern
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            // YouTube URL patterns
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/gi;

            let processedText = escapeHtml(text);
            let linkPreviews = '';

            // Extract URLs for previews (only first URL to avoid clutter)
            const urls = text.match(urlRegex);
            if (urls && urls.length > 0) {
                const firstUrl = urls[0].replace(/["']/g, '');
                // Only show preview if it's not a YouTube URL (YouTube has its own preview)
                if (!firstUrl.match(youtubeRegex)) {
                    linkPreviews = generateLinkPreview(firstUrl);
                }
            }

            // Replace URLs with clickable links
            processedText = processedText.replace(urlRegex, (url) => {
                const cleanUrl = url.replace(/["']/g, '');
                return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" class="message-link">${cleanUrl}</a>`;
            });

            // Check for YouTube links and add previews
            const youtubeMatches = text.match(youtubeRegex);
            if (youtubeMatches) {
                let embedHtml = '';
                youtubeMatches.forEach(match => {
                    // Extract video ID more reliably
                    let videoId = null;
                    
                    // Pattern 1: youtube.com/watch?v=VIDEO_ID
                    const watchMatch = match.match(/youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/);
                    if (watchMatch) {
                        videoId = watchMatch[1];
                    }
                    
                    // Pattern 2: youtu.be/VIDEO_ID
                    const shortMatch = match.match(/youtu\.be\/([a-zA-Z0-9_-]{11})/);
                    if (shortMatch) {
                        videoId = shortMatch[1];
                    }
                    
                    // Pattern 3: youtube.com/embed/VIDEO_ID
                    const embedMatch = match.match(/youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/);
                    if (embedMatch) {
                        videoId = embedMatch[1];
                    }
                    
                    if (videoId) {
                        embedHtml += `
                            <div class="youtube-preview" style="margin: 10px 0; max-width: 300px;">
                                <iframe width="100%" height="200" src="https://www.youtube.com/embed/${videoId}" 
                                        frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                                        allowfullscreen style="border-radius: 8px;"></iframe>
                            </div>
                        `;
                    }
                });
                processedText += embedHtml;
            }

            // Add link previews
            processedText += linkPreviews;

            return processedText;
        }

        function generateLinkPreview(url) {
            try {
                new URL(url); // Validate URL
            } catch {
                return ''; // Don't show preview for invalid URLs
            }
            
            // For demo purposes, create a basic preview
            // In production, you'd use a backend service to fetch metadata
            const domain = new URL(url).hostname;
            
            // Try to fetch metadata using a CORS proxy (this is a basic implementation)
            fetchLinkMetadata(url).then(metadata => {
                if (metadata) {
                    updateLinkPreview(url, metadata);
                }
            }).catch(() => {
                // Fallback to basic preview
                console.log('Could not fetch metadata for:', url);
            });
            
            return `
                <div class="link-preview" onclick="window.open('${url}', '_blank')" data-url="${url}">
                    <div class="link-preview-content">
                        <div class="link-preview-title">Loading preview...</div>
                        <div class="link-preview-description">${domain}</div>
                        <div class="link-preview-url">${url}</div>
                    </div>
                </div>
            `;
        }

        async function fetchLinkMetadata(url) {
            try {
                // Use a CORS proxy to fetch metadata
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                const response = await fetch(proxyUrl);
                const data = await response.json();
                const html = data.contents;
                
                // Parse HTML to extract metadata
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                const title = doc.querySelector('title')?.textContent || 
                             doc.querySelector('meta[property="og:title"]')?.getAttribute('content') ||
                             doc.querySelector('meta[name="title"]')?.getAttribute('content') ||
                             'No title';
                
                const description = doc.querySelector('meta[property="og:description"]')?.getAttribute('content') ||
                                   doc.querySelector('meta[name="description"]')?.getAttribute('content') ||
                                   'No description';
                
                const image = doc.querySelector('meta[property="og:image"]')?.getAttribute('content') ||
                             doc.querySelector('meta[name="image"]')?.getAttribute('content');
                
                return { title, description, image };
            } catch (error) {
                console.error('Error fetching link metadata:', error);
                return null;
            }
        }

        function updateLinkPreview(url, metadata) {
            const preview = document.querySelector(`.link-preview[data-url="${url}"]`);
            if (preview) {
                const titleEl = preview.querySelector('.link-preview-title');
                const descEl = preview.querySelector('.link-preview-description');
                
                if (titleEl) titleEl.textContent = metadata.title;
                if (descEl) descEl.textContent = metadata.description;
                
                if (metadata.image) {
                    const imageDiv = document.createElement('div');
                    imageDiv.className = 'link-preview-image';
                    imageDiv.style.backgroundImage = `url(${metadata.image})`;
                    preview.insertBefore(imageDiv, preview.firstChild);
                }
            }
        }

        async function getUserName(userId) {
            try {
                const userDoc = await getDoc(doc(db, "users", userId));
                if (userDoc.exists()) {
                    return userDoc.data().name;
                }
            } catch (error) {
                console.error('Error getting user name:', error);
            }
            return 'User';
        }

        function showToast(message, type = 'success') {
            const existingToast = document.querySelector('.toast-notification');
            if (existingToast) {
                existingToast.remove();
            }

            const toast = document.createElement('div');
            toast.className = `toast-notification ${type}`;
            toast.textContent = message;

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        async function loadMessageData(messageId) {
            try {
                const messageDoc = await getDoc(doc(db, "messages", messageId));
                if (messageDoc.exists()) {
                    currentMessageData = messageDoc.data();
                }
            } catch (error) {
                console.error('Error loading message data:', error);
            }
        }

        async function resetUnreadCount(chatId) {
            try {
                await updateDoc(doc(db, "chats", chatId), {
                    [`unreadCount.${currentUser.uid}`]: 0
                });
            } catch (error) {
                console.error('Error resetting unread count:', error);
            }
        }

        async function markMessagesAsRead() {
            if (!currentChatId || !currentUser) return;

            try {
                // Update chat readBy
                await updateDoc(doc(db, "chats", currentChatId), {
                    readBy: arrayUnion(currentUser.uid)
                });

                // Update individual messages readBy
                const messagesQuery = query(
                    collection(db, "messages"),
                    where("chatId", "==", currentChatId),
                    where("sender", "!=", currentUser.uid)
                );

                const messagesSnapshot = await getDocs(messagesQuery);
                const updatePromises = [];

                messagesSnapshot.forEach((docSnapshot) => {
                    const message = docSnapshot.data();
                    if (!message.readBy || !message.readBy.includes(currentUser.uid)) {
                        updatePromises.push(
                            updateDoc(doc(db, "messages", docSnapshot.id), {
                                readBy: arrayUnion(currentUser.uid)
                            })
                        );
                    }
                });

                await Promise.all(updatePromises);

            } catch (error) {
                console.error('Error marking messages as read:', error);
            }
        }

        function setupTypingListener() {
            if (!currentUser) return;

            const typingQuery = query(
                collection(db, "chats"),
                where("participants", "array-contains", currentUser.uid)
            );

            onSnapshot(typingQuery, (snapshot) => {
                snapshot.forEach((docSnapshot) => {
                    const chat = docSnapshot.data();
                    if (chat.isGroup && currentGroupId === docSnapshot.id) {
                        const typingUsers = Object.keys(chat.typing || {}).filter(id =>
                            id !== currentUser.uid && chat.typing[id]
                        );

                        if (typingUsers.length > 0) {
                            showGroupTypingIndicator(typingUsers);
                        } else {
                            hideTypingIndicator();
                        }
                    } else {
                        const otherUserId = chat.participants.find(id => id !== currentUser.uid);

                        if (otherUserId && chat.typing && chat.typing[otherUserId] && currentChatId === docSnapshot.id) {
                            showTypingIndicator(otherUserId);
                        } else if (currentChatId === docSnapshot.id) {
                            hideTypingIndicator();
                        }
                    }
                });
            });
        }

        async function showTypingIndicator(userId) {
            hideTypingIndicator();

            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            `;

            const messageRow = document.createElement('div');
            messageRow.className = 'message-row received';
            messageRow.appendChild(typingDiv);

            messagesContainer.appendChild(messageRow);

            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        async function showGroupTypingIndicator(userIds) {
            hideTypingIndicator();

            const userNames = [];
            for (const userId of userIds.slice(0, 2)) {
                const userName = await getUserName(userId);
                userNames.push(userName);
            }

            let typingText = '';
            if (userNames.length === 1) {
                typingText = `${userNames[0]} is typing...`;
            } else if (userNames.length === 2) {
                typingText = `${userNames[0]} and ${userNames[1]} are typing...`;
            } else {
                typingText = `${userNames[0]} and ${userIds.length - 1} others are typing...`;
            }

            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <span style="margin-left: 8px; font-size: 12px; color: #8696a0;">${typingText}</span>
            `;

            const messageRow = document.createElement('div');
            messageRow.className = 'message-row received';
            messageRow.appendChild(typingDiv);

            messagesContainer.appendChild(messageRow);

            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        function hideTypingIndicator() {
            const existingIndicator = document.getElementById('typingIndicator');
            if (existingIndicator) {
                existingIndicator.parentElement.remove();
            }
        }

        function showUploadProgress(fileName, fileSize) {
            uploadFileName.textContent = `${fileName} (${formatFileSize(fileSize)})`;
            uploadProgressFill.style.width = '0%';
            uploadProgressText.textContent = '0%';

            const warningElement = document.getElementById('uploadFileWarning');
            if (fileSize > 2 * 1024 * 1024) {
                warningElement.style.display = 'flex';
            } else {
                warningElement.style.display = 'none';
            }

            uploadProgressModal.style.display = 'block';
        }

        function updateUploadProgress(percent, fileName) {
            uploadProgressFill.style.width = `${percent}%`;
            uploadProgressText.textContent = `${percent}%`;

            if (percent === 100) {
                uploadFileName.textContent = `${fileName} - Complete!`;
            }
        }

        function hideUploadProgress() {
            uploadProgressModal.style.display = 'none';
        }

        function showLargeFileUploadModal(file, fileType) {
            largeFileName.textContent = file.name;
            largeFileSize.textContent = formatFileSize(file.size);
            largeFileProgressFill.style.width = '0%';
            largeFileProgressText.textContent = '0%';
            largeFileUploadModal.style.display = 'block';
        }

        function updateLargeFileProgress(percent, currentChunk, totalChunks) {
            largeFileProgressFill.style.width = `${percent}%`;
            largeFileProgressText.textContent = `${percent}%`;
            chunkInfo.textContent = `Chunk ${currentChunk} of ${totalChunks}`;
        }

        function hideLargeFileUploadModal() {
            largeFileUploadModal.style.display = 'none';
        }

        window.cancelLargeFileUpload = () => {
            pendingFileTransfers.forEach((transfer, transferId) => {
                if (transfer.conn && transfer.conn.open) {
                    transfer.conn.close();
                }
            });
            pendingFileTransfers.clear();

            hideLargeFileUploadModal();
            showToast('File upload cancelled', 'warning');
        };

        // ====== NETWORK STATUS ======
        function monitorNetworkStatus() {
            window.addEventListener('online', () => {
                updateNetworkStatus(true, 'Back online');
                showToast('You are back online', 'success');
            });

            window.addEventListener('offline', () => {
                updateNetworkStatus(false, 'You are offline');
                showToast('You are offline', 'error');
            });

            updateNetworkStatus(navigator.onLine, navigator.onLine ? 'Connected' : 'Offline');
        }

        function updateNetworkStatus(isOnline, message) {
            if (!networkStatus) return;

            networkStatus.style.display = 'flex';
            networkStatus.className = `network-status ${isOnline ? 'online' : 'offline'}`;
            networkStatus.innerHTML = `
                <i class="fas fa-${isOnline ? 'wifi' : 'exclamation-triangle'}"></i>
                <span>${message}</span>
            `;

            if (isOnline) {
                setTimeout(() => {
                    if (networkStatus.classList.contains('online')) {
                        networkStatus.style.display = 'none';
                    }
                }, 3000);
            }
        }

        // ====== MENU FUNCTIONS ======
        menuToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            menuDropdown.classList.toggle('active');
        });

        window.showSettings = () => {
            menuDropdown.classList.remove('active');
            const settModal = document.getElementById('settingsModal');

            // Update modal with current data
            document.getElementById('settingsUserName').textContent = currentUser.displayName || 'You';
            const avatar = document.getElementById('settingsUserAvatar');
            if (userProfilePicture) {
                avatar.style.backgroundImage = `url(${userProfilePicture})`;
                avatar.textContent = '';
            } else {
                avatar.style.backgroundImage = '';
                avatar.textContent = (currentUser.displayName || 'Y').charAt(0);
                avatar.style.display = 'flex';
                avatar.style.alignItems = 'center';
                avatar.style.justifyContent = 'center';
                avatar.style.background = '#00a884';
                avatar.style.color = 'white';
                avatar.style.fontSize = '24px';
            }

            settModal.classList.add('active');
        };

        window.hideSettings = () => {
            document.getElementById('settingsModal').classList.remove('active');
        };

        window.showArchivedChats = () => {
            menuDropdown.classList.remove('active');
            showToast('Archived chats feature coming soon!', 'warning');
        };

        window.showStarredMessages = () => {
            menuDropdown.classList.remove('active');
            showToast('Starred messages feature coming soon!', 'warning');
        };

        function toggleChatMenu() {
            showToast('Chat menu options:\n1. View Contact\n2. Mute Notifications\n3. Search in Chat\n4. Clear Chat\n5. Delete Chat', 'warning');
        }

        window.logout = async () => {
            if (!confirm('Are you sure you want to logout?')) return;

            try {
                menuDropdown.classList.remove('active');

                if (currentUser) {
                    await updateDoc(doc(db, "users", currentUser.uid), {
                        online: false,
                        lastSeen: serverTimestamp()
                    });
                }

                handleCallEnded();
                stopRingtone();

                incomingCallModal.classList.remove('active');
                outgoingCallModal.classList.remove('active');
                profileModal.classList.remove('active');
                deleteChatModal.classList.remove('active');
                profileUploadModal.classList.remove('active');
                locationPickerModal.classList.remove('active');
                forwardModal.classList.remove('active');
                groupCreationModal.classList.remove('active');
                hideUploadProgress();
                hideLargeFileUploadModal();
                hideLargeFileDownloadModal();

                stopVibration();

                if (messageUnsubscribe) messageUnsubscribe();
                if (chatsUnsubscribe) chatsUnsubscribe();

                if (peer) {
                    try {
                        peer.destroy();
                    } catch (e) {
                        console.log('Error destroying peer on logout:', e);
                    }
                    peer = null;
                }

                activeCallConnections.forEach(conn => {
                    try {
                        conn.close();
                    } catch (e) {
                        console.log('Error closing connection:', e);
                    }
                });
                activeCallConnections.clear();

                pendingFileTransfers.forEach((transfer, transferId) => {
                    if (transfer.conn && transfer.conn.open) {
                        transfer.conn.close();
                    }
                });
                pendingFileTransfers.clear();

                activeFileTransfers.clear();
                chatCache.clear();

                await signOut(auth);

                localStorage.removeItem('rememberedEmail');

                currentUser = null;
                currentChatId = null;
                currentContact = null;
                currentGroupId = null;
                messageToDelete = null;
                deleteOption = null;
                currentMessageData = null;
                isInCall = false;
                activeCall = null;
                incomingCallData = null;
                outgoingCallData = null;
                chatToDelete = null;
                userProfilePicture = null;
                currentLocation = null;
                largeFileUpload = null;
                locationPickerActive = false;
                messageToForward = null;
                forwardToContact = null;
                selectedGroupMembers.clear();

                chatList.innerHTML = `
                    <div class="empty-chat">
                        <div class="empty-chat-icon">
                            <i class="fas fa-comments"></i>
                        </div>
                        <h3>Your chats will appear here</h3>
                        <p>Search for users to start new conversations.</p>
                    </div>
                `;

                messagesContainer.innerHTML = `
                    <div class="empty-chat">
                        <div class="empty-chat-icon">
                            <i class="fas fa-comment-slash"></i>
                        </div>
                        <h3>No chat selected</h3>
                        <p>Select a chat from the list or search for a user to start messaging.</p>
                    </div>
                `;

                contactName.textContent = 'Select a chat';
                contactStatus.textContent = 'Click on a chat to start messaging';
                contactAvatar.textContent = 'C';
                contactAvatar.style.backgroundImage = '';
                contactAvatar.style.backgroundColor = '#6a7175';
                onlineDot.style.display = 'none';
                searchInput.value = '';
                messageInput.value = '';
                cancelReply();
                hideTypingIndicator();
                networkStatus.style.display = 'none';

                document.getElementById('emojiPickerContainer').style.display = 'none';
                attachmentMenu.classList.remove('active');

                console.log('âœ… User logged out successfully');

            } catch (error) {
                console.error('âŒ Error logging out:', error);
                showToast('Error logging out. Please try again.', 'error');
            }

            // Show authContainer and hide appContainer
            try {
                authContainer.style.display = 'block';
                appContainer.style.display = 'none';
                
                // Clear login form
                const loginEmail = document.getElementById('loginEmail');
                const loginPassword = document.getElementById('loginPassword');
                if (loginEmail) loginEmail.value = '';
                if (loginPassword) loginPassword.value = '';
                
                console.log('âœ… Redirected to login page');
            } catch (e) {
                console.error('Redirect error:', e);
                location.reload();
            }
        };

        // ====== EMOJI PICKER (PICMO) ======
        let emojiPicker = null;

        function initializePicmoPicker() {
            const container = document.getElementById('emojiPickerContainer');

            if (!window.picmo) {
                console.error('âŒ PicMo not loaded');
                return;
            }

            if (emojiPicker) return; // prevent re-init

            emojiPicker = window.picmo.createPicker({
                rootElement: container,
                rows: 6,
                columns: 8,
                emojiSize: 28
            });

            emojiPicker.addEventListener('emoji:select', (event) => {
                messageInput.value += event.emoji;
                messageInput.focus();
                handleTyping();

                if (window.innerWidth <= 768) {
                    container.style.display = 'none';
                }
            });

            console.log('âœ… PicMo emoji picker initialized');
        }

        window.toggleEmojiPicker = () => {
            const container = document.getElementById('emojiPickerContainer');
            container.classList.toggle('show');
            
            // Close attachment menu when opening emoji picker
            document.getElementById('attachmentMenu').classList.remove('active');
            
            // Prevent body scroll on mobile when picker is open
            if (container.classList.contains('show') && window.innerWidth <= 768) {
                document.body.style.overflow = 'hidden';
            } else {
                document.body.style.overflow = '';
            }
        };

        window.toggleAttachmentMenu = () => {
            attachmentMenu.classList.toggle('active');
            document.getElementById('emojiPickerContainer').classList.remove('show');
            document.body.style.overflow = '';
        };

        // ====== EMOJI PICKER INITIALIZATION ======
        function initializeEmojiPicker() {
            const emojiPickerContainer = document.getElementById('emojiPickerContainer');
            const messageInput = document.getElementById('messageInput');
            
            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'emoji-picker-close';
            closeBtn.innerHTML = '<i class="fas fa-times"></i>';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                emojiPickerContainer.classList.remove('show');
                document.body.style.overflow = '';
            };
            emojiPickerContainer.appendChild(closeBtn);
            
            // Create and insert emoji-picker element
            const emojiPicker = document.createElement('emoji-picker');
            emojiPicker.id = 'emojiPicker';
            emojiPickerContainer.appendChild(emojiPicker);
            
            // Handle emoji selection
            emojiPicker.addEventListener('emoji-click', (event) => {
                messageInput.value += event.detail.unicode;
                messageInput.focus();
                emojiPickerContainer.classList.remove('show');
                document.body.style.overflow = '';
            });
            
            // Close picker when clicking on backdrop (mobile only)
            document.addEventListener('click', (event) => {
                if (window.innerWidth <= 768 && 
                    emojiPickerContainer.classList.contains('show') &&
                    event.target === emojiPickerContainer.previousElementSibling) {
                    emojiPickerContainer.classList.remove('show');
                    document.body.style.overflow = '';
                }
            });
            
            console.log('âœ… Emoji picker initialized with beautiful close button');
        }

        // ====== INITIALIZATION ======
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ðŸš€ WebChat App initialized');
            
            // Initialize emoji picker after DOM is ready
            setTimeout(() => initializeEmojiPicker(), 100);

            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            document.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;

                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;

                if (Math.abs(diffX) > 50 && Math.abs(diffY) < 50) {
                    if (diffX > 0 && window.innerWidth <= 768 && chatArea.classList.contains('active')) {
                        showChatList();
                    }
                }
            });

            const loginEmail = document.getElementById('loginEmail');
            if (loginEmail) loginEmail.focus();

            messageInput.addEventListener('input', () => {
                if (messageInput.value.trim() === '') {
                    micButton.style.display = 'block';
                    sendButton.style.display = 'none';
                } else {
                    micButton.style.display = 'none';
                    sendButton.style.display = 'flex';
                }
            });

            messageInput.addEventListener('paste', async (e) => {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        e.preventDefault();
                        const file = items[i].getAsFile();
                        await handleImagePaste(file);
                        break;
                    }
                }
            });

            document.addEventListener('visibilitychange', () => {
                if (document.hidden && isInCall) {
                    console.log('ðŸ“± App minimized during call');
                }
            });

            window.addEventListener('beforeunload', () => {
                if (isInCall) {
                    endCall();
                }

                if (peer) {
                    try {
                        peer.destroy();
                    } catch (e) {
                        console.log('Error destroying peer:', e);
                    }
                    peer = null;
                }

                stopRingtone();
                stopVibration();
                activeFileTransfers.clear();
                chatCache.clear();

                activeCallConnections.forEach(conn => {
                    try {
                        conn.close();
                    } catch (e) {
                        console.log('Error closing connection:', e);
                    }
                });

                pendingFileTransfers.forEach((transfer, transferId) => {
                    if (transfer.conn && transfer.conn.open) {
                        transfer.conn.close();
                    }
                });
                pendingFileTransfers.clear();
            });

            document.addEventListener('click', (e) => {
                const emojiContainer = document.getElementById('emojiPickerContainer');
                if (!emojiContainer.contains(e.target) && !emojiButton.contains(e.target)) {
                    emojiContainer.style.display = 'none';
                }

                if (!attachmentMenu.contains(e.target) && !attachmentButton.contains(e.target)) {
                    attachmentMenu.classList.remove('active');
                }

                if (!menuDropdown.contains(e.target) && !menuToggle.contains(e.target)) {
                    menuDropdown.classList.remove('active');
                }

                const modals = [
                    deleteModal, deleteChatModal, profileModal,
                    profileUploadModal, locationPickerModal,
                    largeFileDownloadModal, forwardModal, groupCreationModal
                ];

                modals.forEach(modal => {
                    if (modal.contains(e.target) && e.target === modal) {
                        modal.classList.remove('active');
                    }
                });

                if (uploadProgressModal.style.display === 'block' && !uploadProgressModal.contains(e.target)) {
                    hideUploadProgress();
                }

                if (largeFileUploadModal.style.display === 'block' && !largeFileUploadModal.contains(e.target)) {
                    cancelLargeFileUpload();
                }

                // if (!messageContextMenu.contains(e.target) && messageContextMenuActive) { // Removed as per new context menu logic
                //     hideMessageContextMenu();
                // }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const modals = [
                        deleteModal, deleteChatModal, profileModal,
                        profileUploadModal, locationPickerModal,
                        incomingCallModal, outgoingCallModal, largeFileDownloadModal,
                        forwardModal, groupCreationModal
                    ];

                    modals.forEach(modal => modal.classList.remove('active'));

                    emojiPickerContainer.classList.remove('active');
                    attachmentMenu.classList.remove('active');
                    menuDropdown.classList.remove('active');
                    // hideMessageContextMenu(); // Removed as per new context menu logic

                    hideUploadProgress();
                    hideLargeFileUploadModal();

                    if (locationPickerActive) {
                        closeLocationPicker();
                    }

                    if (isInCall) {
                        endCall();
                    }
                }
            });

            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (messagesContainer) {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                }, 300);
            });

            window.addEventListener('resize', () => {
                if (window.innerWidth > 768) {
                    sidebar.classList.remove('hidden');
                    chatArea.classList.add('active');
                    document.querySelector('.back-to-chats').style.display = 'none';
                    swipeHint.style.display = 'none';
                } else if (chatArea.classList.contains('active')) {
                    sidebar.classList.add('hidden');
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'P') {
                    performanceOverlay.style.display = performanceOverlay.style.display === 'block' ? 'none' : 'block';
                }
            });

            // ====== SEARCH FUNCTIONS ======
            window.searchUsers = debounce(async () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                const chatList = document.getElementById('chatList');

                if (!searchTerm) {
                    loadChats();
                    return;
                }

                chatList.innerHTML = '<div class="spinner"></div>';

                try {
                    const usersQuery = query(collection(db, "users"));
                    const snapshot = await getDocs(usersQuery);

                    chatList.innerHTML = '';
                    let foundCount = 0;

                    snapshot.forEach(doc => {
                        const user = doc.data();
                        if (user.uid === currentUser.uid) return;

                        if (user.name.toLowerCase().includes(searchTerm) || user.email.toLowerCase().includes(searchTerm)) {
                            renderSearchResult(user);
                            foundCount++;
                        }
                    });

                    if (foundCount === 0) {
                        chatList.innerHTML = `
                        <div class="empty-chat">
                            <div class="empty-chat-icon"><i class="fas fa-search"></i></div>
                            <p>No users found matching "${escapeHtml(searchTerm)}"</p>
                        </div>`;
                    }

                } catch (error) {
                    console.error("Search error:", error);
                    chatList.innerHTML = `<div class="error-state">Error searching users</div>`;
                }
            }, 500);

            function renderSearchResult(user) {
                const chatList = document.getElementById('chatList');
                const div = document.createElement('div');
                div.className = 'chat-item';

                const profilePic = user.profilePicture;
                const avatarStyle = profilePic
                    ? `background-image: url(${profilePic}); background-size: cover; background-position: center;`
                    : `background-color: ${user.avatarColor || '#25D366'}`;
                const avatarContent = profilePic ? '' : user.name.charAt(0).toUpperCase();

                div.innerHTML = `
                <div class="avatar-container">
                    <div class="chat-avatar" style="${avatarStyle}">${avatarContent}</div>
                </div>
                <div class="chat-info">
                    <div class="chat-header">
                        <h3 class="chat-name">${escapeHtml(user.name)}</h3>
                    </div>
                    <div class="chat-preview">
                        <div class="chat-message">${escapeHtml(user.email)}</div>
                    </div>
                </div>
            `;

                div.onclick = () => startChat(user);
                chatList.appendChild(div);
            }

            window.startChat = async (user) => {
                // Find existing chat or create new
                const participants = [currentUser.uid, user.uid].sort();
                // Simple check: most P2P chats are just these 2 participants.
                // But checking via query is safer or constructs ID if determined by UID combo.
                // Let's assume we want to query first.
                let chatId = null;

                try {
                    // Try to find a chat with exactly these 2 participants
                    const q = query(collection(db, "chats"), where("participants", "==", participants));
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        chatId = snapshot.docs[0].id;
                    } else {
                        // Create new chat
                        const newChatRef = await addDoc(collection(db, "chats"), {
                            participants: participants,
                            createdAt: serverTimestamp(),
                            lastMessage: '',
                            lastMessageTime: serverTimestamp(),
                            unreadCount: { [currentUser.uid]: 0, [user.uid]: 0 },
                            typing: {}
                        });
                        chatId = newChatRef.id;
                    }

                    // Select this chat
                    // We need to reload chats or manually trigger selection
                    // Reuse existing selection logic if possible or reload
                    currentChatId = chatId;
                    currentContact = user;
                    currentGroupId = null;

                    // UI updates
                    contactName.textContent = user.name;
                    contactStatus.textContent = "online"; // simplified
                    const profilePic = await loadProfilePicture(user.uid);
                    if (profilePic) {
                        contactAvatar.style.backgroundImage = `url(${profilePic})`;
                        contactAvatar.textContent = '';
                    } else {
                        contactAvatar.style.backgroundImage = '';
                        contactAvatar.textContent = user.name.charAt(0);
                        contactAvatar.style.backgroundColor = user.avatarColor || '#25D366';
                    }

                    // Reset views
                    if (window.innerWidth <= 768) {
                        document.getElementById('sidebar').classList.add('hidden');
                        document.getElementById('chatArea').classList.add('active');
                    }

                    loadMessages(chatId);
                    searchInput.value = ''; // Clear search
                    loadChats(); // Reload sidebar list

                } catch (e) {
                    console.error("Error starting chat:", e);
                    showToast("Failed to start chat", "error");
                }
            };

            // ====== STATUS FEATURE LOGIC ======
            let myStatusUpdates = [];
            let viewableStatuses = [];
            let currentViewStatusIndex = 0;
            let currentViewUserStatuses = [];
            let statusInterval = null;

            window.toggleStatusView = () => {
                const statusView = document.getElementById('statusView');
                const chatList = document.getElementById('chatList');
                const searchBox = document.querySelector('.search-box');

                if (statusView.classList.contains('active')) {
                    statusView.classList.remove('active');
                    chatList.style.display = 'block';
                    if (searchBox) searchBox.style.display = 'block';
                } else {
                    statusView.classList.add('active');
                    chatList.style.display = 'none';
                    if (searchBox) searchBox.style.display = 'none';
                    loadStatuses();
                }
            };

            window.handleMyStatusClick = () => {
                if (myStatusUpdates && myStatusUpdates.length > 0) {
                    openStatusViewer(myStatusUpdates);
                } else {
                    document.getElementById('statusUploadInput').click();
                }
            };

            window.showMyStatusManagement = () => {
                if (myStatusUpdates && myStatusUpdates.length > 0) {
                    // Open viewer but show delete more prominently or just open viewer
                    openStatusViewer(myStatusUpdates);
                } else {
                    showToast('No status updates to manage', 'info');
                }
            };

            document.getElementById('statusUploadInput').addEventListener('change', async (e) => {
                const files = e.target.files;
                if (!files.length) return;

                showToast('Uploading status...');

                for (let file of files) {
                    if (file.size > 5 * 1024 * 1024) {
                        showToast(`Skipped ${file.name} (too large)`, 'warning');
                        continue;
                    }
                    const base64 = await fileToBase64(file);
                    const type = file.type.startsWith('image') ? 'image' : 'video';

                    await addDoc(collection(db, "statuses"), {
                        uid: currentUser.uid,
                        userName: await getUserName(currentUser.uid, false), // Helper
                        content: base64,
                        type: type,
                        timestamp: serverTimestamp(),
                        viewers: [],
                        likes: []
                    });
                }
                showToast('Status uploaded!');
                loadStatuses();
            });

            async function loadStatuses() {
                const statusList = document.getElementById('statusList');
                if (!statusList) return;
                statusList.innerHTML = '<div class="spinner"></div>';

                try {
                    // Get all statuses from last 24h
                    const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
                    const q = query(collection(db, "statuses"), where("timestamp", ">", yesterday), orderBy("timestamp", "desc"));
                    const snapshot = await getDocs(q);

                    myStatusUpdates = [];
                    const otherStatusesMap = new Map();

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        data.id = doc.id;
                        if (data.uid === currentUser.uid) {
                            myStatusUpdates.push(data);
                        } else {
                            if (!otherStatusesMap.has(data.uid)) {
                                otherStatusesMap.set(data.uid, {
                                    uid: data.uid,
                                    userName: data.userName,
                                    statuses: []
                                });
                            }
                            otherStatusesMap.get(data.uid).statuses.push(data);
                        }
                    });

                    // Render My Status Avatar
                    const myAvatar = document.getElementById('myStatusAvatar');
                    const myStatusTime = document.getElementById('myStatusTime');
                    const myDeleteBtn = document.getElementById('myStatusDeleteBtn');
                    const myStatusRing = document.getElementById('myStatusRing');
                    const myAddIcon = document.querySelector('.add-status-icon');

                    if (myStatusUpdates.length > 0) {
                        const last = myStatusUpdates[0];
                        myAvatar.style.backgroundImage = last.type === 'image' ? `url(${last.content})` : `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg>')`;
                        myAvatar.classList.remove('no-status');
                        myStatusTime.textContent = formatTime(last.timestamp.toDate());
                        myDeleteBtn.style.display = 'flex';
                        myStatusRing.style.display = 'block';
                        myAddIcon.style.display = 'none';
                    } else {
                        myAvatar.style.backgroundImage = userProfilePicture ? `url(${userProfilePicture})` : '';
                        myAvatar.classList.add('no-status');
                        myStatusTime.textContent = 'Click to add status update';
                        myDeleteBtn.style.display = 'none';
                        myStatusRing.style.display = 'none';
                        myAddIcon.style.display = 'flex';
                    }

                    // Render Other Statuses
                    statusList.innerHTML = '';
                    if (otherStatusesMap.size === 0) {
                        statusList.innerHTML = '<div style="padding:20px; text-align:center; color:#8696a0">No recent updates</div>';
                        return;
                    }

                    for (let userStatus of otherStatusesMap.values()) {
                        await renderStatusItem(userStatus, statusList);
                    }

                } catch (e) {
                    console.error("Error loading statuses", e);
                }
            }

            async function renderStatusItem(userStatus, container) {
                // Check if all viewed
                // We need to check viewers array in each status
                // Simple logic: if any status in array is NOT viewed by me, ring is green.
                const hasUnseen = userStatus.statuses.some(s => !s.viewers || !s.viewers.includes(currentUser.uid));

                const div = document.createElement('div');
                div.className = 'status-item';
                div.onclick = () => openStatusViewer(userStatus.statuses);

                const lastStatus = userStatus.statuses[0]; // Most recent
                const previewUrl = lastStatus.type === 'image' ? lastStatus.content : lastStatus.content; // Use video thumbnail or content

                // Get profile pic
                const profilePic = await loadProfilePicture(userStatus.uid);

                const time = formatTime(lastStatus.timestamp.toDate());

                let avatarStyle = '';
                let avatarText = '';
                if (lastStatus.type === 'image') {
                    avatarStyle = `background-image: url(${lastStatus.content})`;
                } else if (lastStatus.type === 'video') {
                    // For videos, show profile pic with video overlay
                    if (profilePic) {
                        avatarStyle = `background-image: url(${profilePic})`;
                        avatarText = '';
                    } else {
                        avatarStyle = 'background-color: #00a884';
                        avatarText = userStatus.userName.charAt(0);
                    }
                } else if (profilePic) {
                    avatarStyle = `background-image: url(${profilePic})`;
                    avatarText = '';
                } else {
                    avatarStyle = 'background-color: #00a884';
                    avatarText = userStatus.userName.charAt(0);
                }

                div.innerHTML = `
                <div class="status-avatar-wrapper">
                    <div class="status-ring ${hasUnseen ? '' : 'viewed'}"></div>
                    <div class="status-avatar" style="${avatarStyle}">
                        ${avatarText}
                        ${lastStatus.type === 'video' ? '<i class="fas fa-play video-status-icon"></i>' : ''}
                    </div>
                </div>
                <div class="status-info">
                    <h3>${userStatus.userName}</h3>
                    <p>${time}</p>
                </div>
             `;
                container.appendChild(div);
            }

            window.openStatusViewer = (statuses) => {
                if (!statuses || !statuses.length) return;
                // Sort by time ascending
                currentViewUserStatuses = statuses.sort((a, b) => a.timestamp - b.timestamp);
                currentViewStatusIndex = 0;
                document.getElementById('statusModal').classList.add('active');
                showStatus(0);
            };

            function showStatus(index) {
                if (index >= currentViewUserStatuses.length) {
                    closeStatusModal();
                    return;
                }
                if (index < 0) return;

                currentViewStatusIndex = index;
                const status = currentViewUserStatuses[index];

                // Update Header
                document.getElementById('statusViewName').textContent = status.userName || 'User';
                document.getElementById('statusViewTime').textContent = formatTime(status.timestamp.toDate());

                // Update Footer controls (Like/View)
                const deleteBtn = document.getElementById('statusDeleteBtn');
                const viewsContainer = document.getElementById('statusViewsContainer');
                const likeContainer = document.getElementById('statusLikeContainer');
                const viewCount = document.getElementById('statusViewCount');
                const likeIcon = document.getElementById('statusLikeIcon');

                if (status.uid === currentUser.uid) {
                    deleteBtn.style.display = 'block';
                    likeContainer.style.display = 'none';
                    viewsContainer.style.display = 'flex';
                    const viewers = status.viewers || [];
                    viewCount.textContent = viewers.length;
                } else {
                    deleteBtn.style.display = 'none';
                    viewsContainer.style.display = 'none';
                    likeContainer.style.display = 'block';

                    // Mark as viewed logic
                    if (!status.viewers || !status.viewers.includes(currentUser.uid)) {
                        updateDoc(doc(db, "statuses", status.id), {
                            viewers: arrayUnion(currentUser.uid)
                        }).catch(console.error);
                        // Add locally to avoid flicker
                        if (!status.viewers) status.viewers = [];
                        status.viewers.push(currentUser.uid);
                    }

                    // Check like status
                    if (status.likes && status.likes.includes(currentUser.uid)) {
                        likeIcon.className = 'fas fa-heart';
                        likeIcon.style.color = '#ff0000';
                    } else {
                        likeIcon.className = 'far fa-heart';
                        likeIcon.style.color = 'white';
                    }
                }

                // Render bars
                const barsContainer = document.getElementById('statusProgressBar');
                barsContainer.innerHTML = '';
                currentViewUserStatuses.forEach((s, i) => {
                    const seg = document.createElement('div');
                    seg.className = 'status-progress-segment';
                    const fill = document.createElement('div');
                    fill.className = 'status-progress-fill';
                    if (i < index) fill.style.width = '100%';
                    else if (i > index) fill.style.width = '0%';
                    seg.appendChild(fill);
                    barsContainer.appendChild(seg);
                });

                // Render Content
                const contentView = document.getElementById('statusContentView');
                contentView.innerHTML = '';

                if (status.type === 'image') {
                    const img = document.createElement('img');
                    img.src = status.content;
                    contentView.appendChild(img);
                    startStatusTimer(5000);
                } else {
                    const video = document.createElement('video');
                    video.src = status.content;
                    video.autoplay = true;
                    video.controls = false;
                    contentView.appendChild(video);
                    video.onended = () => showStatus(index + 1);
                    startStatusTimer(0, video);
                }
            }

            function startStatusTimer(duration, videoEl) {
                if (statusInterval) clearInterval(statusInterval);

                const bars = document.querySelectorAll('.status-progress-fill');
                const currentBar = bars[currentViewStatusIndex];

                if (duration > 0) {
                    currentBar.style.transition = `width ${duration}ms linear`;
                    // Trigger reflow
                    void currentBar.offsetWidth;
                    currentBar.style.width = '100%';

                    statusInterval = setTimeout(() => {
                        showStatus(currentViewStatusIndex + 1);
                    }, duration);
                } else if (videoEl) {
                    // For video, we bind to timeupdate
                    currentBar.style.width = '0%';
                    currentBar.style.transition = 'none';

                    videoEl.ontimeupdate = () => {
                        if (videoEl.duration) {
                            const pct = (videoEl.currentTime / videoEl.duration) * 100;
                            currentBar.style.width = `${pct}%`;
                        }
                    };
                }
            }

            window.closeStatusModal = () => {
                document.getElementById('statusModal').classList.remove('active');
                if (statusInterval) clearInterval(statusInterval);
                const video = document.querySelector('#statusContentView video');
                if (video) video.pause();
                loadStatuses(); // reload to update seen status
            };

            window.deleteCurrentStatus = async () => {
                if (confirm("Delete this status update?")) {
                    const status = currentViewUserStatuses[currentViewStatusIndex];
                    if (status && status.id) {
                        await deleteDoc(doc(db, "statuses", status.id));
                        showDeleteSuccessNotification("Status deleted");
                        // Remove from list
                        currentViewUserStatuses.splice(currentViewStatusIndex, 1);
                        if (currentViewUserStatuses.length === 0) {
                            closeStatusModal();
                        } else {
                            // show next or previous
                            if (currentViewStatusIndex >= currentViewUserStatuses.length) {
                                currentViewStatusIndex--;
                            }
                            showStatus(currentViewStatusIndex);
                        }
                    }
                }
            };

            window.toggleLikeStatus = async () => {
                const status = currentViewUserStatuses[currentViewStatusIndex];
                if (!status || !status.id) return;

                const likeIcon = document.getElementById('statusLikeIcon');

                // Optimistic UI update
                const isLiked = status.likes && status.likes.includes(currentUser.uid);

                if (isLiked) {
                    likeIcon.className = 'far fa-heart';
                    likeIcon.style.color = 'white';
                    likeIcon.style.transform = 'scale(0.8)';
                    setTimeout(() => likeIcon.style.transform = 'scale(1)', 100);

                    // Remove from local array
                    status.likes = status.likes.filter(uid => uid !== currentUser.uid);

                    try {
                        await updateDoc(doc(db, "statuses", status.id), {
                            likes: arrayRemove(currentUser.uid)
                        });
                    } catch (e) { console.error(e); }
                } else {
                    likeIcon.className = 'fas fa-heart';
                    likeIcon.style.color = '#ff0000';
                    likeIcon.style.transform = 'scale(1.2)';
                    setTimeout(() => likeIcon.style.transform = 'scale(1)', 100);

                    // Add to local array
                    if (!status.likes) status.likes = [];
                    status.likes.push(currentUser.uid);

                    try {
                        await updateDoc(doc(db, "statuses", status.id), {
                            likes: arrayUnion(currentUser.uid)
                        });
                    } catch (e) { console.error(e); }
                }
            };

            // Long press helper
            let msgLongPressTimer;
            window.handleMessageLongPress = (e, el) => {
                msgLongPressTimer = setTimeout(() => {
                    showMessageContextMenu(e, el);
                }, 800);
            };
            window.clearMessageLongPress = () => {
                if (msgLongPressTimer) clearTimeout(msgLongPressTimer);
            };

            async function getUserName(uid, forDisplay = true) {
                // Check cache or fetch
                // Simple fetch for now
                if (forDisplay && uid === currentUser.uid) return "You";
                try {
                    const d = await getDoc(doc(db, "users", uid));
                    if (d.exists()) return d.data().name;
                } catch (e) { }
                return 'Unknown';
            }

            // ====== CONTEXT MENU LOGIC ======
            let currentContextMenuMessage = null;

            window.showMessageContextMenu = (e, element) => {
                e.preventDefault();
                // Close any open menu
                document.querySelectorAll('.message-context-menu').forEach(m => m.classList.remove('active'));

                currentContextMenuMessage = element;
                const menu = document.getElementById('messageContextMenu');
                if (!menu) return;

                // Position menu
                // Use lastTouch coords for mobile if event doesn't have them
                const x = e.clientX || window.lastTouchX || (e.touches && e.touches[0].clientX);
                const y = e.clientY || window.lastTouchY || (e.touches && e.touches[0].clientY);

                // Get menu dimensions (use actual or estimated)
                const menuWidth = 220;
                const menuHeight = 240;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const padding = 10;

                let left = x;
                let top = y;

                // Mobile-specific positioning (center on small screens if needed)
                if (viewportWidth <= 768) {
                    // For mobile, try to position near touch but ensure visibility
                    if (left + menuWidth > viewportWidth - padding) {
                        left = viewportWidth - menuWidth - padding;
                    }
                    if (left < padding) {
                        left = padding;
                    }

                    // Vertical positioning
                    if (top + menuHeight > viewportHeight - padding) {
                        top = viewportHeight - menuHeight - padding;
                    }
                    if (top < padding) {
                        top = padding;
                    }
                } else {
                    // Desktop positioning
                    if (left + menuWidth > viewportWidth) left = viewportWidth - menuWidth - padding;
                    if (top + menuHeight > viewportHeight) top = viewportHeight - menuHeight - padding;
                    if (left < padding) left = padding;
                    if (top < padding) top = padding;
                }

                menu.style.left = `${left}px`;
                menu.style.top = `${top}px`;
                menu.classList.add('active');

                // Close when clicking outside
                const closeMenu = (ev) => {
                    if (!menu.contains(ev.target)) {
                        menu.classList.remove('active');
                        document.removeEventListener('click', closeMenu);
                        document.removeEventListener('touchstart', closeMenu);
                        currentContextMenuMessage = null;
                    }
                };

                // Delay to prevent immediate closing from the trigger click
                setTimeout(() => {
                    document.addEventListener('click', closeMenu);
                    document.addEventListener('touchstart', closeMenu);
                }, 100);
            };

            window.copyMessageText = () => {
                if (currentContextMenuMessage) {
                    const messageType = currentContextMenuMessage.dataset.type;
                    const messageText = currentContextMenuMessage.dataset.text || '';
                    const messageContent = currentContextMenuMessage.dataset.content || '';

                    if (messageType === 'image' && messageContent) {
                        // For images, copy the image URL
                        navigator.clipboard.writeText(messageContent);
                        showToast("Image URL copied to clipboard");
                    } else if (messageText) {
                        // For text messages, copy the text
                        navigator.clipboard.writeText(messageText);
                        showToast("Message copied to clipboard");
                    } else {
                        showToast("No content to copy", "warning");
                    }
                }
            };

            window.replyToMessage = () => {
                if (currentContextMenuMessage) {
                    const text = currentContextMenuMessage.dataset.text || '[Attachment]';
                    const senderId = currentContextMenuMessage.dataset.sender;
                    const messageId = currentContextMenuMessage.dataset.id;

                    replyingTo = {
                        id: messageId,
                        text: text,
                        sender: senderId
                    };

                    getUserName(senderId).then(name => {
                        replySender.textContent = name;
                        replyTextEl.textContent = text;
                        replyPreview.classList.add('active');
                        messageInput.focus();
                    });
                }
            };

            window.cancelReply = () => {
                replyingTo = null;
                replyPreview.classList.remove('active');
            };

            window.scrollToMessage = (id) => {
                const el = document.querySelector(`[data-id="${id}"]`);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    el.classList.add('highlight-message');
                    setTimeout(() => el.classList.remove('highlight-message'), 2000);
                } else {
                    showToast("Message not found in history", "warning");
                }
            };

            window.closeForwardModal = () => {
                forwardModal.classList.remove('active');
                messageToForward = null;
            };

            window.forwardMessage = () => {
                if (currentContextMenuMessage) {
                    messageToForward = {
                        text: currentContextMenuMessage.dataset.text || '',
                        type: currentContextMenuMessage.dataset.type || 'text',
                        content: currentContextMenuMessage.dataset.content || null,
                        fileName: currentContextMenuMessage.dataset.fileName || null,
                        fileSize: currentContextMenuMessage.dataset.fileSize || null,
                        fileType: currentContextMenuMessage.dataset.fileType || null,
                        address: currentContextMenuMessage.dataset.address || null,
                        latitude: currentContextMenuMessage.dataset.latitude || null,
                        longitude: currentContextMenuMessage.dataset.longitude || null,
                        duration: currentContextMenuMessage.dataset.duration || null,
                        transferId: currentContextMenuMessage.dataset.transferId || null
                    };

                    forwardModal.classList.add('active');
                    loadForwardContacts();
                }
            };

            async function loadForwardContacts() {
                forwardContactList.innerHTML = '<div class="spinner"></div>';
                try {
                    const chatsSnapshot = await getDocs(query(collection(db, "chats"), where("participants", "array-contains", currentUser.uid)));
                    forwardContactList.innerHTML = '';

                    if (chatsSnapshot.empty) {
                        forwardContactList.innerHTML = '<div style="text-align:center; padding:20px; color:#8696a0;">No recent chats</div>';
                        return;
                    }

                    for (const chatDoc of chatsSnapshot.docs) {
                        const chat = chatDoc.data();
                        const otherUserId = chat.participants.find(id => id !== currentUser.uid);
                        let name = "Group Chat";
                        if (!chat.isGroup && otherUserId) {
                            const userDoc = await getDoc(doc(db, "users", otherUserId));
                            name = userDoc.exists() ? userDoc.data().name : "Unknown";
                        } else if (chat.isGroup) {
                            name = chat.groupName;
                        }

                        const div = document.createElement('div');
                        div.className = 'search-result-item';
                        div.innerHTML = `
                            <div class="chat-name">${name}</div>
                            <div class="chat-action-btn select-forward">
                                <i class="fas fa-paper-plane"></i>
                            </div>
                        `;
                        div.onclick = () => confirmForwardMessage(chatDoc.id, name);
                        forwardContactList.appendChild(div);
                    }
                } catch (e) {
                    console.error(e);
                    forwardContactList.innerHTML = 'Error loading contacts';
                }
            }

            window.confirmForwardMessage = async (chatId, name) => {
                if (!messageToForward) return;

                try {
                    const messageData = {
                        chatId: chatId,
                        sender: currentUser.uid,
                        text: messageToForward.text ? CryptoJS.AES.encrypt(messageToForward.text, "secretKey").toString() : '',
                        type: messageToForward.type,
                        timestamp: serverTimestamp(),
                        readBy: [currentUser.uid],
                        delivered: false,
                        deleted: false,
                        deletedFor: [],
                        reactions: {},
                        userReactions: {},
                        replyTo: null
                    };

                    // Add type-specific properties
                    if (messageToForward.content) {
                        messageData.content = messageToForward.content;
                    }
                    if (messageToForward.fileName) {
                        messageData.fileName = messageToForward.fileName;
                    }
                    if (messageToForward.fileSize) {
                        messageData.fileSize = parseInt(messageToForward.fileSize);
                    }
                    if (messageToForward.fileType) {
                        messageData.fileType = messageToForward.fileType;
                    }
                    if (messageToForward.address) {
                        messageData.address = messageToForward.address;
                    }
                    if (messageToForward.latitude) {
                        messageData.latitude = parseFloat(messageToForward.latitude);
                    }
                    if (messageToForward.longitude) {
                        messageData.longitude = parseFloat(messageToForward.longitude);
                    }
                    if (messageToForward.duration) {
                        messageData.duration = messageToForward.duration;
                    }
                    if (messageToForward.transferId) {
                        messageData.transferId = messageToForward.transferId;
                    }

                    await addDoc(collection(db, "messages"), messageData);

                    // Update chat last message
                    let lastMessageText = messageData.text;
                    if (!lastMessageText) {
                        switch (messageToForward.type) {
                            case 'image':
                                lastMessageText = 'ðŸ“· Photo';
                                break;
                            case 'video':
                                lastMessageText = 'ðŸŽ¬ Video';
                                break;
                            case 'voice':
                                lastMessageText = 'ðŸŽµ Voice message';
                                break;
                            case 'document':
                                lastMessageText = 'ðŸ“„ Document';
                                break;
                            case 'location':
                                lastMessageText = 'ðŸ“ Location';
                                break;
                            default:
                                lastMessageText = `[${messageToForward.type}]`;
                        }
                    }

                    const updateData = {
                        lastMessage: lastMessageText,
                        lastMessageTime: serverTimestamp(),
                        sender: currentUser.uid
                    };

                    if (currentGroupId) {
                        updateData.readBy = [currentUser.uid];
                    } else {
                        const chatDoc = await getDoc(doc(db, "chats", chatId));
                        if (chatDoc.exists()) {
                            const chat = chatDoc.data();
                            const otherUserId = chat.participants.find(id => id !== currentUser.uid);
                            if (otherUserId) {
                                updateData[`unreadCount.${otherUserId}`] = increment(1);
                            }
                        }
                    }

                    await updateDoc(doc(db, "chats", chatId), updateData);

                    showToast(`Message forwarded to ${name}`);
                    closeForwardModal();
                } catch (e) {
                    console.error(e);
                    showToast("Failed to forward message", "error");
                }
            };

            window.deleteMessageFromContext = () => {
                if (currentContextMenuMessage) {
                    const id = currentContextMenuMessage.dataset.id;
                    const text = currentContextMenuMessage.dataset.text;
                    if (id) {
                        showDeleteModal(id, text);
                    } else {
                        showToast("Error: Message ID missing", "error");
                    }
                }
            };

            window.closeForwardModal = () => {
                const m = document.getElementById('forwardModal');
                if (m) m.classList.remove('active');
            };

            window.filterForwardContacts = () => {
                const query = document.getElementById('forwardSearch').value.toLowerCase();
                const items = forwardContactList.querySelectorAll('.search-result-item');
                items.forEach(item => {
                    const name = item.querySelector('.chat-name').textContent.toLowerCase();
                    item.style.display = name.includes(query) ? 'flex' : 'none';
                });
            };

            // Load remembered email
            const rememberedEmail = localStorage.getItem('rememberedEmail');
            if (rememberedEmail) {
                document.getElementById('loginEmail').value = rememberedEmail;
            }
        });
    </script>
</body>

</html>
